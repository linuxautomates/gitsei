package io.levelops.integrations.tenable.sources;

import io.levelops.commons.exceptions.RuntimeStreamException;
import io.levelops.commons.functional.PaginationUtils;
import io.levelops.ingestion.data.BasicData;
import io.levelops.ingestion.data.Data;
import io.levelops.ingestion.exceptions.FetchException;
import io.levelops.ingestion.sources.DataSource;
import io.levelops.integrations.tenable.client.TenableClient;
import io.levelops.integrations.tenable.client.TenableClientException;
import io.levelops.integrations.tenable.client.TenableClientFactory;
import io.levelops.integrations.tenable.models.ExportResponse;
import io.levelops.integrations.tenable.models.ExportStatusResponse;
import io.levelops.integrations.tenable.models.TenableScanQuery;
import io.levelops.integrations.tenable.models.Vulnerability;
import lombok.extern.log4j.Log4j2;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Tenable's implementation of the {@link DataSource}. This class is used for fetching vulnerability from tenable.
 */
@Log4j2
public class TenableVulnerabilityDataSource implements DataSource<Vulnerability, TenableScanQuery> {
    private final TenableClientFactory clientFactory;

    public TenableVulnerabilityDataSource(TenableClientFactory clientFactory) {
        this.clientFactory = clientFactory;
    }

    @Override
    public Data<Vulnerability> fetchOne(TenableScanQuery query) {
        throw new UnsupportedOperationException("FetchOne not supported");
    }

    @Override
    public Stream<Data<Vulnerability>> fetchMany(TenableScanQuery query) throws FetchException {
        TenableClient tenableClient = clientFactory.get(query.getIntegrationKey());
        ExportResponse exportResponse = tenableClient.exportVulnerabilities(query);
        String exportUUID = exportResponse.getExportUUID();
        ChunkPageData initialChunkPageData = new ChunkPageData(exportUUID, null,
                false, null, new ArrayList<>(), new ArrayList<>());
        ChunkPageSupplier chunkPageSupplier = new ChunkPageSupplier
                (initialChunkPageData, chunkPageData -> getVulnData(tenableClient, chunkPageData));
        return PaginationUtils.stream(chunkPageSupplier, ChunkPageSupplier.predicate)
                .filter(chunkPageData -> chunkPageData.getChunkId() != null)
                .map(chunkPageData -> {
                    try {
                        log.debug("Downloading vulnerability chunk with id: {} for uuid: {}",
                                chunkPageData.getChunkId(), chunkPageData.getUuid());
                        List<Vulnerability> vulnerabilities = tenableClient.downloadVulnerabilityChunk(chunkPageData.getUuid(), chunkPageData.getChunkId());
                        chunkPageData.getChunksProcessed().add(chunkPageData.getChunkId());
                        return vulnerabilities.stream().map(BasicData.mapper(Vulnerability.class)).collect(Collectors.toList());
                    } catch (TenableClientException e) {
                        log.error("Encountered tenable client error for integration key: "
                                + query.getIntegrationKey() + " as : " + e.getMessage(), e);
                        throw new RuntimeStreamException("Encountered tenable client error for integration key: " + query.getIntegrationKey(), e);
                    }
                })
                .flatMap(List::stream);
    }

    private ChunkPageData getVulnData(TenableClient tenableClient, ChunkPageData chunkPageData) {
        try {
            ExportStatusResponse exportStatus = tenableClient.getVulnerabilitiesExportStatus(chunkPageData.uuid);
            Set<Integer> chunksAvailableSet = new HashSet<>(exportStatus.getChunksAvailable());
            Set<Integer> chunksProcessedSet = new HashSet<>(chunkPageData.getChunksProcessed());
            log.debug("Available chunk size: {}, downloaded chunk size: {}",
                    chunksAvailableSet.size(), chunksProcessedSet.size());
            chunksAvailableSet.removeAll(chunksProcessedSet);
            if (chunksAvailableSet.size() > 0) {
                Integer chunkId = chunksAvailableSet.iterator().next();
                return ChunkPageData.builder()
                        .uuid(chunkPageData.getUuid())
                        .done(chunkPageData.getDone())
                        .chunkId(chunkId)
                        .chunksAvailable(exportStatus.getChunksAvailable())
                        .chunksProcessed(chunkPageData.getChunksProcessed())
                        .status(exportStatus.getStatus())
                        .build();
            } else {
                return ChunkPageData.builder()
                        .uuid(chunkPageData.getUuid())
                        .done(chunkPageData.getDone())
                        .chunkId(null)
                        .chunksAvailable(exportStatus.getChunksAvailable())
                        .chunksProcessed(chunkPageData.getChunksProcessed())
                        .status(exportStatus.getStatus())
                        .build();
            }
        } catch (TenableClientException e) {
            log.error("Encountered tenable client exception. Reason: " + e.getMessage(), e);
            throw new RuntimeStreamException("Encountered tenable client exception", e);
        }
    }
}
