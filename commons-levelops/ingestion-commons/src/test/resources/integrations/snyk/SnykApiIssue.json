{"ok":false,"issues":{"vulnerabilities":[{"id":"SNYK-JAVA-ORGYAML-537645","url":"https://snyk.io/vuln/SNYK-JAVA-ORGYAML-537645","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n`org.yaml:snakeyaml` is a YAML 1.1 parser and emitter for Java.\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nThe Alias feature in SnakeYAML 1.18 allows entity expansion during a load operation, a related issue to CVE-2003-1564.\r\n\r\n*Note* While the Maintainer acknowledges the existence of the issue, they believe it should be solved by sanitizing the `inputStream` to the parser\n\n## Remediation\n\nThere is no fixed version for `org.yaml:snakeyaml`.\n\n\n## References\n\n- [Bitbucket Issue](https://bitbucket.org/asomov/snakeyaml/issues/377/allow-configuration-for-preventing-billion)\n\n- [Maintainer Report](https://bitbucket.org/asomov/snakeyaml/wiki/Billion%20laughs%20attack)\n\n- [Proof Of Concept](https://bitbucket.org/asomov/snakeyaml/commits/04378d05777d21d114a9cdc24976ad49c8919222)\n","from":["org.fusesource.scalate:scalate-page@1.5.3","org.yaml:snakeyaml@1.7"],"package":"org.yaml:snakeyaml","version":"1.7","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,]"]},"publicationTime":"2019-12-19T03:28:21Z","disclosureTime":"2019-12-12T03:28:21Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-18640"],"CWE":["CWE-189"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N/E:U/RL:T/RC:U","cvssScore":4.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-ORGSCALALANG-31592","url":"https://snyk.io/vuln/SNYK-JAVA-ORGSCALALANG-31592","title":"Arbitrary Code Execution","type":"vuln","description":"## Overview\nAffected versions of [`org.scala-lang:scala-compiler`](https://scala-lang.org) are vulnerable to Arbitrary Code Execution.\n\nThe compilation daemon in Scala before 2.10.7, 2.11.x before 2.11.12, and 2.12.x before 2.12.4 uses weak permissions for private files in /tmp/scala-devel/${USER:shared}/scalac-compile-server-port, which allows local users to write to arbitrary class files and consequently gain privileges.\n\n## Remediation\nUpgrade `org.scala-lang:scala-compiler` to version 2.12.4 or higher.\n\n## References\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-15288)\n- [GitHub PR #1](https://github.com/scala/scala/pull/6108)\n- [GitHub PR #2](https://github.com/scala/scala/pull/6120)\n- [GitHub PR #3](https://github.com/scala/scala/pull/6128)\n- [GitHub Commit #1](https://github.com/scala/scala/commit/f3419fc358a8ea6e366538126279da88d4d1fb1f)\n- [GitHub Commit #2](https://github.com/scala/scala/commit/67fcf5ce4496000574676d81ed72e4a6cb9e7757)\n- [GitHub Commit #3](https://github.com/scala/scala/commit/0f624c5e5bdb39967e208c7c16067c3e6c903f1f)\n","from":["org.fusesource.scalate:scalate-page@1.5.3","org.fusesource.scalate:scalate-core@1.5.3","org.scala-lang:scala-compiler@2.9.1"],"package":"org.scala-lang:scala-compiler","version":"2.9.1","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.10.7),[2.11,2.11.12),[2.12,2.12.4)"]},"publicationTime":"2017-11-28T14:47:22.036000Z","disclosureTime":"2017-10-02T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-15288"],"CWE":["CWE-94"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H","cvssScore":7.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-ORGSCALALANG-31592","url":"https://snyk.io/vuln/SNYK-JAVA-ORGSCALALANG-31592","title":"Arbitrary Code Execution","type":"vuln","description":"## Overview\nAffected versions of [`org.scala-lang:scala-compiler`](https://scala-lang.org) are vulnerable to Arbitrary Code Execution.\n\nThe compilation daemon in Scala before 2.10.7, 2.11.x before 2.11.12, and 2.12.x before 2.12.4 uses weak permissions for private files in /tmp/scala-devel/${USER:shared}/scalac-compile-server-port, which allows local users to write to arbitrary class files and consequently gain privileges.\n\n## Remediation\nUpgrade `org.scala-lang:scala-compiler` to version 2.12.4 or higher.\n\n## References\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-15288)\n- [GitHub PR #1](https://github.com/scala/scala/pull/6108)\n- [GitHub PR #2](https://github.com/scala/scala/pull/6120)\n- [GitHub PR #3](https://github.com/scala/scala/pull/6128)\n- [GitHub Commit #1](https://github.com/scala/scala/commit/f3419fc358a8ea6e366538126279da88d4d1fb1f)\n- [GitHub Commit #2](https://github.com/scala/scala/commit/67fcf5ce4496000574676d81ed72e4a6cb9e7757)\n- [GitHub Commit #3](https://github.com/scala/scala/commit/0f624c5e5bdb39967e208c7c16067c3e6c903f1f)\n","from":["org.fusesource.scalate:scalate-page@1.5.3","org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.scalate:scalate-core@1.5.3","org.scala-lang:scala-compiler@2.9.1"],"package":"org.scala-lang:scala-compiler","version":"2.9.1","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.10.7),[2.11,2.11.12),[2.12,2.12.4)"]},"publicationTime":"2017-11-28T14:47:22.036000Z","disclosureTime":"2017-10-02T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-15288"],"CWE":["CWE-94"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H","cvssScore":7.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMGOOGLEGUAVA-32236","url":"https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","org.scalastuff:scalabeans@0.2","com.google.guava:guava@r09"],"package":"com.google.guava:guava","version":"r09","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[11.0, 24.1.1-android)","(24.1.1-android, 24.1.1-jre)"]},"publicationTime":"2018-05-02T13:38:04Z","disclosureTime":"2018-04-25T07:28:15Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-10237"],"CWE":["CWE-119"]},"credit":["Apostolos Giannakidis"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H","cvssScore":5.9,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-ORGSCALALANG-31592","url":"https://snyk.io/vuln/SNYK-JAVA-ORGSCALALANG-31592","title":"Arbitrary Code Execution","type":"vuln","description":"## Overview\nAffected versions of [`org.scala-lang:scala-compiler`](https://scala-lang.org) are vulnerable to Arbitrary Code Execution.\n\nThe compilation daemon in Scala before 2.10.7, 2.11.x before 2.11.12, and 2.12.x before 2.12.4 uses weak permissions for private files in /tmp/scala-devel/${USER:shared}/scalac-compile-server-port, which allows local users to write to arbitrary class files and consequently gain privileges.\n\n## Remediation\nUpgrade `org.scala-lang:scala-compiler` to version 2.12.4 or higher.\n\n## References\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-15288)\n- [GitHub PR #1](https://github.com/scala/scala/pull/6108)\n- [GitHub PR #2](https://github.com/scala/scala/pull/6120)\n- [GitHub PR #3](https://github.com/scala/scala/pull/6128)\n- [GitHub Commit #1](https://github.com/scala/scala/commit/f3419fc358a8ea6e366538126279da88d4d1fb1f)\n- [GitHub Commit #2](https://github.com/scala/scala/commit/67fcf5ce4496000574676d81ed72e4a6cb9e7757)\n- [GitHub Commit #3](https://github.com/scala/scala/commit/0f624c5e5bdb39967e208c7c16067c3e6c903f1f)\n","from":["org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.scalate:scalate-core@1.5.3","org.scala-lang:scala-compiler@2.9.1"],"package":"org.scala-lang:scala-compiler","version":"2.9.1","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.10.7),[2.11,2.11.12),[2.12,2.12.4)"]},"publicationTime":"2017-11-28T14:47:22.036000Z","disclosureTime":"2017-10-02T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-15288"],"CWE":["CWE-94"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H","cvssScore":7.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825","title":"Unsafe Dependancy Resolution","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.module:jackson-module-scala](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-scala) is an Add-on module for Jackson (http://wiki.fasterxml.com/JacksonHome) to support Scala-specific datatypes.\n\n\nAffected versions of this package are vulnerable to Unsafe Dependancy Resolution\ndue to resolving dependencies over an insecure channel (http).\r\n\r\nIf the build occurred over an insecure connection, a malicious user could have perform a Man-in-the-Middle attack during the build and alter the build artifacts that were produced.\r\nIn case that any of these artifacts were compromised, any developers using these could be altered.\r\n \r\n**Note:** In order to validate that this artifact was not compromised, the maintainer would need to confirm that none of the artifacts published to the registry were not altered with. Until this happens, we can not guarantee that this artifact was not compromised even though the probability that this happened is low. \r\n\r\nWe have chosen to alert on this issue when maintainers either decided to issue CVEs themselves, or in cases when maintainers decided against performing audits on there build to verify they had not been compromised.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.module:jackson-module-scala` to version 2.9.9 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-module-scala/pull/406/commits/a2d13cea104ee790759519ade6f2f688791e8198)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-module-scala/issues/400)\n\n- [Jonathan Leitschuh's Blog](https://medium.com/@jonathan.leitschuh/1fc329d898fb)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0"],"package":"com.fasterxml.jackson.module:jackson-module-scala","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.9)"]},"publicationTime":"2019-06-11T11:38:42Z","disclosureTime":"2019-02-22T12:35:55Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-494","CWE-829"]},"credit":["JLLeitschuh"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L","cvssScore":5.6,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0","com.fasterxml.jackson.core:jackson-core@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-core","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.6)"]},"publicationTime":"2017-09-20T15:28:35Z","disclosureTime":"2017-01-12T00:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-399"]},"credit":["Alessio Soldano"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L","cvssScore":5.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-core@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-core","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.6)"]},"publicationTime":"2017-09-20T15:28:35Z","disclosureTime":"2017-01-12T00:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-399"]},"credit":["Alessio Soldano"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L","cvssScore":5.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0","com.fasterxml.jackson.core:jackson-core@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-core","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.6)"]},"publicationTime":"2017-09-20T15:28:35Z","disclosureTime":"2017-01-12T00:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-399"]},"credit":["Alessio Soldano"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L","cvssScore":5.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-core@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-core","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.6)"]},"publicationTime":"2017-09-20T15:28:35Z","disclosureTime":"2017-01-12T00:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-399"]},"credit":["Alessio Soldano"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L","cvssScore":5.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0","com.fasterxml.jackson.core:jackson-core@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-core","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.6)"]},"publicationTime":"2017-09-20T15:28:35Z","disclosureTime":"2017-01-12T00:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-399"]},"credit":["Alessio Soldano"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L","cvssScore":5.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519","title":"Denial of Service (DoS)","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-core@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-core","version":"2.0.0","severity":"medium","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.6)"]},"publicationTime":"2017-09-20T15:28:35Z","disclosureTime":"2017-01-12T00:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-399"]},"credit":["Alessio Soldano"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L","cvssScore":5.3,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:44Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19360"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:43Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19361"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:44Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19362"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:24:39Z","disclosureTime":"2018-07-27T17:24:46Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14721"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:19:17Z","disclosureTime":"2018-07-27T17:20:17Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14720"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:22:38Z","disclosureTime":"2018-07-27T17:22:45Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14719"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0-RC1, 2.7.9.4)","[2.8.0.rc1, 2.8.11.2)","[2.9.0,2.9.6)"]},"publicationTime":"2018-10-11T17:15:49Z","disclosureTime":"2018-05-29T17:15:50Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-12023"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:19:41Z","disclosureTime":"2018-07-27T17:19:49Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14718"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0.RC1, 2.7.9.4)","[2.8.0.rc1, 2.8.11.2)","[2.9.0, 2.9.6)"]},"publicationTime":"2018-10-11T17:10:50Z","disclosureTime":"2018-05-10T17:10:58Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-11307"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.7.9.4)","[2.8.0,2.8.11.2)","[2.9.0,2.9.6)"]},"publicationTime":"2018-10-11T17:00:03Z","disclosureTime":"2018-05-29T17:00:04Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-12022"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10)"]},"publicationTime":"2019-10-07T01:14:26Z","disclosureTime":"2019-10-07T01:14:26Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-17267"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.1)"]},"publicationTime":"2019-10-02T17:43:33Z","disclosureTime":"2019-10-01T17:43:33Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16942"],"CWE":["CWE-502"]},"credit":["bsmali4"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.2)"]},"publicationTime":"2020-01-03T05:14:08Z","disclosureTime":"2020-01-03T05:14:08Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-20330"],"CWE":["CWE-502"]},"credit":["UltramanGaia"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0, 2.9.10.1)"]},"publicationTime":"2019-10-13T07:41:55Z","disclosureTime":"2019-10-12T21:52:10Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-17531"],"CWE":["CWE-502"]},"credit":["Zhangxianhui"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":8.1,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.1)"]},"publicationTime":"2019-10-02T17:43:33Z","disclosureTime":"2019-10-01T17:43:33Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16943"],"CWE":["CWE-502"]},"credit":["bsmali4"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr2)","[,2.9.10)"]},"publicationTime":"2019-09-16T14:37:37Z","disclosureTime":"2019-09-16T14:37:38Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-502"]},"credit":["Tatu Saloranta"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr2)","[,2.9.10)"]},"publicationTime":"2019-09-16T23:27:25Z","disclosureTime":"2019-09-15T23:27:25Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-14540"],"CWE":["CWE-502"]},"credit":["iSafeBlue"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.2)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-07-29T12:40:42Z","disclosureTime":"2019-07-29T12:40:42Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-14379","CVE-2019-14439"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr3)","[,2.9.10)"]},"publicationTime":"2019-09-16T23:30:24Z","disclosureTime":"2019-09-15T23:30:24Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16335"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.1)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-06-25T10:26:29Z","disclosureTime":"2019-05-28T10:27:59Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12384"],"CWE":["CWE-502"]},"credit":["College of software Nankai University"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.1)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-06-19T14:34:16Z","disclosureTime":"2019-06-19T14:34:16Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12814"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11.1)","[2.9.0, 2.9.5)"]},"publicationTime":"2018-02-26T15:13:40Z","disclosureTime":"2018-02-10T15:13:40Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-7489"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11)","[2.9.0,2.9.4)"]},"publicationTime":"2018-01-23T13:17:24Z","disclosureTime":"2018-01-18T15:40:18Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-5968"],"CWE":["CWE-502"]},"credit":["Rui Chong"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":8.1,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11)","[2.9.0,2.9.4)"]},"publicationTime":"2018-01-22T12:30:55Z","disclosureTime":"2018-01-10T11:41:28Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-17485"],"CWE":["CWE-502"]},"credit":["Imre Rad"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.1)","[2.7.0,2.7.9.1)","[2.8.0,2.8.10)"]},"publicationTime":"2017-11-09T03:13:32Z","disclosureTime":"2017-06-26T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-15095"],"CWE":["CWE-184"]},"credit":["Liao Xinxi"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.1)","[2.7.0,2.7.9.1)","[2.8.0,2.8.9)"]},"publicationTime":"2017-09-14T14:43:48Z","disclosureTime":"2017-04-10T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-7525"],"CWE":["CWE-502"]},"credit":["Liao Xinxi"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9)","[2.8.0,2.8.11.3)","[,2.7.9.6)"]},"publicationTime":"2019-05-17T18:12:58Z","disclosureTime":"2019-05-17T18:12:58Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12086"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:44Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19360"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:43Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19361"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:44Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19362"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:24:39Z","disclosureTime":"2018-07-27T17:24:46Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14721"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:22:38Z","disclosureTime":"2018-07-27T17:22:45Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14719"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:19:17Z","disclosureTime":"2018-07-27T17:20:17Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14720"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:19:41Z","disclosureTime":"2018-07-27T17:19:49Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14718"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0-RC1, 2.7.9.4)","[2.8.0.rc1, 2.8.11.2)","[2.9.0,2.9.6)"]},"publicationTime":"2018-10-11T17:15:49Z","disclosureTime":"2018-05-29T17:15:50Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-12023"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0.RC1, 2.7.9.4)","[2.8.0.rc1, 2.8.11.2)","[2.9.0, 2.9.6)"]},"publicationTime":"2018-10-11T17:10:50Z","disclosureTime":"2018-05-10T17:10:58Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-11307"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.2)"]},"publicationTime":"2020-01-03T05:14:08Z","disclosureTime":"2020-01-03T05:14:08Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-20330"],"CWE":["CWE-502"]},"credit":["UltramanGaia"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.7.9.4)","[2.8.0,2.8.11.2)","[2.9.0,2.9.6)"]},"publicationTime":"2018-10-11T17:00:03Z","disclosureTime":"2018-05-29T17:00:04Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-12022"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0, 2.9.10.1)"]},"publicationTime":"2019-10-13T07:41:55Z","disclosureTime":"2019-10-12T21:52:10Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-17531"],"CWE":["CWE-502"]},"credit":["Zhangxianhui"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":8.1,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10)"]},"publicationTime":"2019-10-07T01:14:26Z","disclosureTime":"2019-10-07T01:14:26Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-17267"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.1)"]},"publicationTime":"2019-10-02T17:43:33Z","disclosureTime":"2019-10-01T17:43:33Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16943"],"CWE":["CWE-502"]},"credit":["bsmali4"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.1)"]},"publicationTime":"2019-10-02T17:43:33Z","disclosureTime":"2019-10-01T17:43:33Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16942"],"CWE":["CWE-502"]},"credit":["bsmali4"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr2)","[,2.9.10)"]},"publicationTime":"2019-09-16T14:37:37Z","disclosureTime":"2019-09-16T14:37:38Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-502"]},"credit":["Tatu Saloranta"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr2)","[,2.9.10)"]},"publicationTime":"2019-09-16T23:27:25Z","disclosureTime":"2019-09-15T23:27:25Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-14540"],"CWE":["CWE-502"]},"credit":["iSafeBlue"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr3)","[,2.9.10)"]},"publicationTime":"2019-09-16T23:30:24Z","disclosureTime":"2019-09-15T23:30:24Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16335"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.2)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-07-29T12:40:42Z","disclosureTime":"2019-07-29T12:40:42Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-14379","CVE-2019-14439"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11)","[2.9.0,2.9.4)"]},"publicationTime":"2018-01-23T13:17:24Z","disclosureTime":"2018-01-18T15:40:18Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-5968"],"CWE":["CWE-502"]},"credit":["Rui Chong"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":8.1,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.1)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-06-25T10:26:29Z","disclosureTime":"2019-05-28T10:27:59Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12384"],"CWE":["CWE-502"]},"credit":["College of software Nankai University"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.1)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-06-19T14:34:16Z","disclosureTime":"2019-06-19T14:34:16Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12814"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11.1)","[2.9.0, 2.9.5)"]},"publicationTime":"2018-02-26T15:13:40Z","disclosureTime":"2018-02-10T15:13:40Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-7489"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11)","[2.9.0,2.9.4)"]},"publicationTime":"2018-01-22T12:30:55Z","disclosureTime":"2018-01-10T11:41:28Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-17485"],"CWE":["CWE-502"]},"credit":["Imre Rad"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.1)","[2.7.0,2.7.9.1)","[2.8.0,2.8.10)"]},"publicationTime":"2017-11-09T03:13:32Z","disclosureTime":"2017-06-26T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-15095"],"CWE":["CWE-184"]},"credit":["Liao Xinxi"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.1)","[2.7.0,2.7.9.1)","[2.8.0,2.8.9)"]},"publicationTime":"2017-09-14T14:43:48Z","disclosureTime":"2017-04-10T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-7525"],"CWE":["CWE-502"]},"credit":["Liao Xinxi"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n","from":["com.fasterxml.jackson.module:jackson-module-scala@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9)","[2.8.0,2.8.11.3)","[,2.7.9.6)"]},"publicationTime":"2019-05-17T18:12:58Z","disclosureTime":"2019-05-17T18:12:58Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12086"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:43Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19361"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:44Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19360"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.8)","[2.8.0,2.8.11.3)","[2.0.0, 2.7.9.5)"]},"publicationTime":"2019-01-03T17:01:51Z","disclosureTime":"2019-01-02T19:18:44Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-19362"],"CWE":["CWE-502"]},"credit":["Wuguixiong"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:22:38Z","disclosureTime":"2018-07-27T17:22:45Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14719"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:24:39Z","disclosureTime":"2018-07-27T17:24:46Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14721"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:19:17Z","disclosureTime":"2018-07-27T17:20:17Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14720"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.2)","[2.7.9, 2.7.9.5)","[2.8.0 ,2.8.11.3)","[2.9.0, 2.9.7)"]},"publicationTime":"2018-10-11T17:19:41Z","disclosureTime":"2018-07-27T17:19:49Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-14718"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0-RC1, 2.7.9.4)","[2.8.0.rc1, 2.8.11.2)","[2.9.0,2.9.6)"]},"publicationTime":"2018-10-11T17:15:49Z","disclosureTime":"2018-05-29T17:15:50Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-12023"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0.RC1, 2.7.9.4)","[2.8.0.rc1, 2.8.11.2)","[2.9.0, 2.9.6)"]},"publicationTime":"2018-10-11T17:10:50Z","disclosureTime":"2018-05-10T17:10:58Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-11307"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.7.9.4)","[2.8.0,2.8.11.2)","[2.9.0,2.9.6)"]},"publicationTime":"2018-10-11T17:00:03Z","disclosureTime":"2018-05-29T17:00:04Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-12022"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H","cvssScore":10,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.2)"]},"publicationTime":"2020-01-03T05:14:08Z","disclosureTime":"2020-01-03T05:14:08Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-20330"],"CWE":["CWE-502"]},"credit":["UltramanGaia"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.0.0, 2.9.10.1)"]},"publicationTime":"2019-10-13T07:41:55Z","disclosureTime":"2019-10-12T21:52:10Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-17531"],"CWE":["CWE-502"]},"credit":["Zhangxianhui"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":8.1,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10)"]},"publicationTime":"2019-10-07T01:14:26Z","disclosureTime":"2019-10-07T01:14:26Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-17267"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.1)"]},"publicationTime":"2019-10-02T17:43:33Z","disclosureTime":"2019-10-01T17:43:33Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16943"],"CWE":["CWE-502"]},"credit":["bsmali4"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.9.10.1)"]},"publicationTime":"2019-10-02T17:43:33Z","disclosureTime":"2019-10-01T17:43:33Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16942"],"CWE":["CWE-502"]},"credit":["bsmali4"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr2)","[,2.9.10)"]},"publicationTime":"2019-09-16T14:37:37Z","disclosureTime":"2019-09-16T14:37:38Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":[],"CWE":["CWE-502"]},"credit":["Tatu Saloranta"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr2)","[,2.9.10)"]},"publicationTime":"2019-09-16T23:27:25Z","disclosureTime":"2019-09-15T23:27:25Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-14540"],"CWE":["CWE-502"]},"credit":["iSafeBlue"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.1)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-06-25T10:26:29Z","disclosureTime":"2019-05-28T10:27:59Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12384"],"CWE":["CWE-502"]},"credit":["College of software Nankai University"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11.1)","[2.9.0, 2.9.5)"]},"publicationTime":"2018-02-26T15:13:40Z","disclosureTime":"2018-02-10T15:13:40Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-7489"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.10.0.pr1,2.10.0.pr3)","[,2.9.10)"]},"publicationTime":"2019-09-16T23:30:24Z","disclosureTime":"2019-09-15T23:30:24Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-16335"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.2)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-07-29T12:40:42Z","disclosureTime":"2019-07-29T12:40:42Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-14379","CVE-2019-14439"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9.1)","[2.8.0,2.8.11.4)","[,2.7.9.6)"]},"publicationTime":"2019-06-19T14:34:16Z","disclosureTime":"2019-06-19T14:34:16Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12814"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11)","[2.9.0,2.9.4)"]},"publicationTime":"2018-01-23T13:17:24Z","disclosureTime":"2018-01-18T15:40:18Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2018-5968"],"CWE":["CWE-502"]},"credit":["Rui Chong"],"CVSSv3":"CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":8.1,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.8.11)","[2.9.0,2.9.4)"]},"publicationTime":"2018-01-22T12:30:55Z","disclosureTime":"2018-01-10T11:41:28Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-17485"],"CWE":["CWE-502"]},"credit":["Imre Rad"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.1)","[2.7.0,2.7.9.1)","[2.8.0,2.8.10)"]},"publicationTime":"2017-11-09T03:13:32Z","disclosureTime":"2017-06-26T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-15095"],"CWE":["CWE-184"]},"credit":["Liao Xinxi"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[2.9.0,2.9.9)","[2.8.0,2.8.11.3)","[,2.7.9.6)"]},"publicationTime":"2019-05-17T18:12:58Z","disclosureTime":"2019-05-17T18:12:58Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2019-12086"],"CWE":["CWE-502"]},"credit":["Unknown"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]},{"id":"SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507","url":"https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507","title":"Deserialization of Untrusted Data","type":"vuln","description":"## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n","from":["com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0","com.fasterxml.jackson.core:jackson-databind@2.0.0"],"package":"com.fasterxml.jackson.core:jackson-databind","version":"2.0.0","severity":"high","exploitMaturity":"no-known-exploit","language":"java","packageManager":"maven","semver":{"vulnerable":["[,2.6.7.1)","[2.7.0,2.7.9.1)","[2.8.0,2.8.9)"]},"publicationTime":"2017-09-14T14:43:48Z","disclosureTime":"2017-04-10T21:00:00Z","isUpgradable":false,"isPatchable":false,"isPinnable":false,"identifiers":{"CVE":["CVE-2017-7525"],"CWE":["CWE-502"]},"credit":["Liao Xinxi"],"CVSSv3":"CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H","cvssScore":9.8,"patches":[],"upgradePath":[]}],"licenses":[{"id":"snyk:lic:maven:rhino:js:MPL-2.0","url":"https://snyk.io/vuln/snyk:lic:maven:rhino:js:MPL-2.0","title":"MPL-2.0 license","type":"license","from":["org.fusesource.scalate:scalate-page@1.5.3","rhino:js@1.7R2"],"package":"rhino:js","version":"1.7R2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[1.7R2,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-page@1.5.3","org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:textile-core@1.2","org.fusesource.wikitext:wikitext-core@1.2"],"package":"org.fusesource.wikitext:wikitext-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-page@1.5.3","org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:confluence-core@1.2","org.fusesource.wikitext:wikitext-core@1.2"],"package":"org.fusesource.wikitext:wikitext-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:textile-core@1.2","org.fusesource.wikitext:wikitext-core@1.2"],"package":"org.fusesource.wikitext:wikitext-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:confluence-core@1.2","org.fusesource.wikitext:wikitext-core@1.2"],"package":"org.fusesource.wikitext:wikitext-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-page@1.5.3","org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:textile-core@1.2"],"package":"org.fusesource.wikitext:textile-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:textile-core@1.2"],"package":"org.fusesource.wikitext:textile-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-page@1.5.3","org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:confluence-core@1.2"],"package":"org.fusesource.wikitext:confluence-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}},{"id":"snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0","url":"https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0","title":"EPL-1.0 license","type":"license","from":["org.fusesource.scalate:scalate-wikitext@1.5.3","org.fusesource.wikitext:confluence-core@1.2"],"package":"org.fusesource.wikitext:confluence-core","version":"1.2","severity":"medium","language":"java","packageManager":"maven","semver":{"vulnerable":["[0,)"]}}]},"dependencyCount":24,"packageManager":"maven"}