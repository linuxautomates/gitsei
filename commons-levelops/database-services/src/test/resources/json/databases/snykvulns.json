[
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "6dc663d5-c309-4c23-b1ac-7311954977a2",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@r09"
            ],
            "package": "com.google.guava:guava",
            "version": "r09",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@10.0"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "title": "Unsafe Dependancy Resolution",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.module:jackson-module-scala](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-scala) is an Add-on module for Jackson (http://wiki.fasterxml.com/JacksonHome) to support Scala-specific datatypes.\n\n\nAffected versions of this package are vulnerable to Unsafe Dependancy Resolution\ndue to resolving dependencies over an insecure channel (http).\r\n\r\nIf the build occurred over an insecure connection, a malicious user could have perform a Man-in-the-Middle attack during the build and alter the build artifacts that were produced.\r\nIn case that any of these artifacts were compromised, any developers using these could be altered.\r\n \r\n**Note:** In order to validate that this artifact was not compromised, the maintainer would need to confirm that none of the artifacts published to the registry were not altered with. Until this happens, we can not guarantee that this artifact was not compromised even though the probability that this happened is low. \r\n\r\nWe have chosen to alert on this issue when maintainers either decided to issue CVEs themselves, or in cases when maintainers decided against performing audits on there build to verify they had not been compromised.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.module:jackson-module-scala` to version 2.9.9 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-module-scala/pull/406/commits/a2d13cea104ee790759519ade6f2f688791e8198)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-module-scala/issues/400)\n\n- [Jonathan Leitschuh's Blog](https://medium.com/@jonathan.leitschuh/1fc329d898fb)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0"
            ],
            "package": "com.fasterxml.jackson.module:jackson-module-scala",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.9)"
              ]
            },
            "publicationTime": 1560253122000,
            "disclosureTime": 1550838955000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-494",
                "CWE-829"
              ]
            },
            "credit": [
              "JLLeitschuh"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 5.6,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          }
        ],
        "licenses": []
      },
      "dependencyCount": 18,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "53ab33ed-350a-4d25-aa7f-c2da831319c4",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-RUBY-JSON-20060",
            "url": "https://snyk.io/vuln/SNYK-RUBY-JSON-20060",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\nThe [`json`](https://rubygems.org/gems/json) gem is a JSON implementation as a Ruby extension in C.\nAffected versions of this Gem are vulnerable to Denial of Service (DoS) attacks and unsafe object creation vulnerabilities. When parsing certain JSON documents, the JSON gem tricked into creating Ruby symbols in a target system.\n\n## Details\n\nWhen parsing certain JSON documents, the JSON gem can be coerced in to creating Ruby symbols in a target system.  Since Ruby symbols are not garbage collected, this can result in a denial of service attack.\n\nThe same technique can be used to create objects in a target system that act like internal objects.  These \"act alike\" objects can be used to bypass certain security mechanisms and can be used as a spring board for SQL injection attacks in Ruby on Rails.\n\nImpacted code looks like this:\n```js\nJSON.parse(user_input)\n```\nWhere the `user_input` variable will have a JSON document like this:\n```json\n{\"json_class\":\"foo\"}\n```\nThe JSON gem will attempt to look up the constant \"foo\".  Looking up this constant will create a symbol.\n\nIn JSON version 1.7.x, objects with arbitrary attributes can be created using JSON documents like this:\n```json\n{\"json_class\":\"JSON::GenericObject\",\"foo\":\"bar\"}\n```\nThis document will result in an instance of `JSON::GenericObject`, with the attribute \"foo\" that has the value \"bar\".  Instantiating these objects will result in arbitrary symbol creation and in some cases can be used to bypass security measures.\n\nPLEASE NOTE: this behavior *does not change* when using `JSON.load`.  `JSON.load` should *never* be given input from unknown sources.  If you are processing JSON from an unknown source, *always* use `JSON.parse`.\n\n## References\n- https://www.ruby-lang.org/en/news/2013/02/22/json-dos-cve-2013-0269/\n- https://gist.github.com/rsierra/4943505\n",
            "from": [
              "swagger@4.06.08",
              "json@1.7.0"
            ],
            "package": "json",
            "version": "1.7.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "ruby",
            "packageManager": "rubygems",
            "semver": {
              "vulnerable": [
                "< 1.7.7, >= 1.7",
                "< 1.6.8, >= 1.6",
                "< 1.5.5"
              ]
            },
            "publicationTime": 1360533600000,
            "disclosureTime": 1360533600000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2013-0269"
              ],
              "CWE": [
                "CWE-400"
              ]
            },
            "credit": [
              "Thomas Hollstegge",
              "Ben Murphy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 7.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-RUBY-JSON-20056",
            "url": "https://snyk.io/vuln/SNYK-RUBY-JSON-20056",
            "title": "Arbitrary Addition Creation",
            "type": "vuln",
            "description": "## Overview\n\nThe [`json`](https://rubygems.org/gems/json) gem is a JSON implementation as a Ruby extension in C.\n\nAffected versions of this gem contain a vulnerability in the `JSON::GenericObject` function which does not restrict users from creating additions, regardless of the state of `create_additions`. This may allow a remote attacker to create arbitrary additions.\n\n## References\n\n- http://spreecommerce.com/blog/multiple-security-vulnerabilities-fixed\n- https://groups.google.com/forum/#!original/rubyonrails-security/4_YvCpLzL58/KBTICG7b4NgJ\n",
            "from": [
              "swagger@4.06.08",
              "json@1.7.0"
            ],
            "package": "json",
            "version": "1.7.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "ruby",
            "packageManager": "rubygems",
            "semver": {
              "vulnerable": [
                "< 1.7.7, >= 1.7.0"
              ]
            },
            "publicationTime": 1359928800000,
            "disclosureTime": 1359928800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-284"
              ]
            },
            "credit": [
              "Steve Root"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
            "cvssScore": 9.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-RUBY-FFI-22037",
            "url": "https://snyk.io/vuln/SNYK-RUBY-FFI-22037",
            "title": "DLL Loading Issue",
            "type": "vuln",
            "description": "## Overview\n[ffi](https://rubygems.org/gems/ffi) is a ruby extension for programmatically loading dynamic libraries, binding functions within them, and calling those functions from Ruby code.\n\nAffected versions of this package are vulnerable to DLL Loading Issue on Windows OS, when a Symbol is used as DLL name instead of a String.\n\n## Remediation\nUpgrade `ffi` to version 1.9.24 or higher.\n\n## References\n- [GitHub Commit](https://github.com/ffi/ffi/commit/e0fe486df0e117ed67b0282b6ada04b7214ca05c)\n",
            "from": [
              "autotest-fsevent@0.2.8",
              "sys-uname@0.9.0",
              "ffi@1.0.11"
            ],
            "package": "ffi",
            "version": "1.0.11",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "ruby",
            "packageManager": "rubygems",
            "semver": {
              "vulnerable": [
                "<1.9.24"
              ]
            },
            "publicationTime": 1530177562937,
            "disclosureTime": 1529688819946,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-1000201"
              ],
              "CWE": [
                "CWE-427"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H",
            "cvssScore": 7.8,
            "patches": [],
            "upgradePath": [
              "autotest-fsevent@0.2.8",
              "sys-uname@0.9.0",
              "ffi@1.9.24"
            ]
          },
          {
            "id": "SNYK-RUBY-CRACK-20049",
            "url": "https://snyk.io/vuln/SNYK-RUBY-CRACK-20049",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[`crack`](https://rubygems.org/gems/crack) is a gem for parsing JSON and XML.\n\nAffected versions of this gem are vulnerable because they do not properly restrict casts of string values. This may allow an attacker to execute arbitrary code, or cause a denial of service (DoS).\n\n## References\n\n- http://rubysec.com/advisories/CVE-2013-1800/\n- https://github.com/rubysec/ruby-advisory-db/issues/25\n",
            "from": [
              "webmock@1.8.6",
              "crack@0.3.1"
            ],
            "package": "crack",
            "version": "0.3.1",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "ruby",
            "packageManager": "rubygems",
            "semver": {
              "vulnerable": [
                "< 0.3.2"
              ]
            },
            "publicationTime": 1357682400000,
            "disclosureTime": 1357682400000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2013-1800"
              ],
              "CWE": [
                "CWE-94"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 7.3,
            "patches": [],
            "upgradePath": [
              "webmock@1.8.6",
              "crack@0.3.2"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:rubygems:sys-uname:Artistic-2.0",
            "url": "https://snyk.io/vuln/snyk:lic:rubygems:sys-uname:Artistic-2.0",
            "title": "Artistic-2.0 license",
            "type": "license",
            "from": [
              "autotest-fsevent@0.2.8",
              "sys-uname@0.9.0"
            ],
            "package": "sys-uname",
            "version": "0.9.0",
            "severity": "medium",
            "language": "ruby",
            "packageManager": "rubygems",
            "semver": {
              "vulnerable": [
                "< 1.1.0, >= 0.7.2"
              ]
            }
          },
          {
            "id": "snyk:lic:rubygems:ffi:LGPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:rubygems:ffi:LGPL-3.0",
            "title": "LGPL-3.0 license",
            "type": "license",
            "from": [
              "autotest-fsevent@0.2.8",
              "sys-uname@0.9.0",
              "ffi@1.0.11"
            ],
            "package": "ffi",
            "version": "1.0.11",
            "severity": "medium",
            "language": "ruby",
            "packageManager": "rubygems",
            "semver": {
              "vulnerable": [
                "< 1.9.3, >= 0.1.0"
              ]
            }
          }
        ]
      },
      "dependencyCount": 20,
      "packageManager": "rubygems"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "6ec24668-c65f-4ac2-ae79-8004c0f9e58b",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:sequencing:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:sequencing:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequencing@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:sequencing",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequencing@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:gui:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:gui:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:gui",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequencing@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 5,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "deda694d-51b6-44f7-8b57-1844b1acdd83",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 3,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "0a0a6900-7513-43a3-9827-d9a8fdff2950",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 5,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "36c0486e-300c-48ad-95ab-d8dda694c94d",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 18,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "aa356026-01f4-4fc4-bbac-3215ac9105a2",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 14,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "78b74007-d0cf-48d8-9bbf-bb57b5d5a7b8",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 5,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "68de136a-edbb-400c-a07b-844a710556c0",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@r09"
            ],
            "package": "com.google.guava:guava",
            "version": "r09",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@10.0"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "title": "Unsafe Dependancy Resolution",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.module:jackson-module-scala](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-scala) is an Add-on module for Jackson (http://wiki.fasterxml.com/JacksonHome) to support Scala-specific datatypes.\n\n\nAffected versions of this package are vulnerable to Unsafe Dependancy Resolution\ndue to resolving dependencies over an insecure channel (http).\r\n\r\nIf the build occurred over an insecure connection, a malicious user could have perform a Man-in-the-Middle attack during the build and alter the build artifacts that were produced.\r\nIn case that any of these artifacts were compromised, any developers using these could be altered.\r\n \r\n**Note:** In order to validate that this artifact was not compromised, the maintainer would need to confirm that none of the artifacts published to the registry were not altered with. Until this happens, we can not guarantee that this artifact was not compromised even though the probability that this happened is low. \r\n\r\nWe have chosen to alert on this issue when maintainers either decided to issue CVEs themselves, or in cases when maintainers decided against performing audits on there build to verify they had not been compromised.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.module:jackson-module-scala` to version 2.9.9 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-module-scala/pull/406/commits/a2d13cea104ee790759519ade6f2f688791e8198)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-module-scala/issues/400)\n\n- [Jonathan Leitschuh's Blog](https://medium.com/@jonathan.leitschuh/1fc329d898fb)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0"
            ],
            "package": "com.fasterxml.jackson.module:jackson-module-scala",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.9)"
              ]
            },
            "publicationTime": 1560253122000,
            "disclosureTime": 1550838955000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-494",
                "CWE-829"
              ]
            },
            "credit": [
              "JLLeitschuh"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 5.6,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          }
        ],
        "licenses": []
      },
      "dependencyCount": 18,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "135b9b88-8313-4ca9-bc8f-5c0153d9b0a9",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:biosql:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:biosql:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:biosql",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 4,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "a41b25d3-67be-4b55-a8c2-9e6a0f61ad87",
      "ok": true,
      "issues": {
        "vulnerabilities": [],
        "licenses": []
      },
      "dependencyCount": 1,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "fdc13338-3099-4413-9851-8d1cac53eaac",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:blast:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:blast:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:blast",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 4,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "d7be4602-9199-45c2-859c-16d7753d0666",
      "ok": true,
      "issues": {
        "vulnerabilities": [],
        "licenses": []
      },
      "dependencyCount": 0,
      "packageManager": "gradle"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "c8a2c51a-15a1-474f-8d0a-5721f6e269aa",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-XERCES-32014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-XERCES-32014",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[xerces:xercesimpl](http://xerces.apache.org) is an that is used for high performance, fully compliant XML parsers in the Apache Xerces family.\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\n`XMLScanner.java` in Apache Xerces2 Java, as used in Sun Java Runtime Environment (JRE) in JDK and JRE 6 before Update 15 and JDK and JRE 5.0 before Update 20, and in other products, allows remote attackers to cause a denial of service (infinite loop and application hang) via malformed XML input, as demonstrated by the Codenomicon XML fuzzing framework.\n\n## Details\nA cross-site scripting attack occurs when the attacker tricks a legitimate web-based application or site to accept a request as originating from a trusted source.\r\n\r\nThis is done by escaping the context of the web application; the web application then delivers that data to its users along with other trusted dynamic content, without validating it. The browser unknowingly executes malicious script on the client side (through client-side languages; usually JavaScript or HTML)  in order to perform actions that are otherwise typically blocked by the browser’s Same Origin Policy.\r\n\r\nֿInjecting malicious code is the most prevalent manner by which XSS is exploited; for this reason, escaping characters in order to prevent this manipulation is the top method for securing code against this vulnerability.\r\n\r\nEscaping means that the application is coded to mark key characters, and particularly key characters included in user input, to prevent those characters from being interpreted in a dangerous context. For example, in HTML, `<` can be coded as  `&lt`; and `>` can be coded as `&gt`; in order to be interpreted and displayed as themselves in text, while within the code itself, they are used for HTML tags. If malicious content is injected into an application that escapes special characters and that malicious content uses `<` and `>` as HTML tags, those characters are nonetheless not interpreted as HTML tags by the browser if they’ve been correctly escaped in the application code and in this way the attempted attack is diverted.\r\n \r\nThe most prominent use of XSS is to steal cookies (source: OWASP HttpOnly) and hijack user sessions, but XSS exploits have been used to expose sensitive information, enable access to privileged services and functionality and deliver malware. \r\n\r\n### Types of attacks\r\nThere are a few methods by which XSS can be manipulated:\r\n\r\n|Type|Origin|Description|\r\n|--|--|--|\r\n|**Stored**|Server|The malicious code is inserted in the application (usually as a link) by the attacker. The code is activated every time a user clicks the link.|\r\n|**Reflected**|Server|The attacker delivers a malicious link externally from the vulnerable web site application to a user. When clicked, malicious code is sent to the vulnerable web site, which reflects the attack back to the user’s browser.| \r\n|**DOM-based**|Client|The attacker forces the user’s browser to render a malicious page. The data in the page itself delivers the cross-site scripting data.|\r\n|**Mutated**| |The attacker injects code that appears safe, but is then rewritten and modified by the browser, while parsing the markup. An example is rebalancing unclosed quotation marks or even adding quotation marks to unquoted parameters.|\r\n\r\n### Affected environments\r\nThe following environments are susceptible to an XSS attack:\r\n\r\n* Web servers\r\n* Application servers\r\n* Web application environments\r\n\r\n### How to prevent\r\nThis section describes the top best practices designed to specifically protect your code: \r\n\r\n* Sanitize data input in an HTTP request before reflecting it back, ensuring all data is validated, filtered or escaped before echoing anything back to the user, such as the values of query parameters during searches. \r\n* Convert special characters such as `?`, `&`, `/`, `<`, `>` and spaces to their respective HTML or URL encoded equivalents. \r\n* Give users the option to disable client-side scripts.\r\n* Redirect invalid requests.\r\n* Detect simultaneous logins, including those from two separate IP addresses, and invalidate those sessions.\r\n* Use and enforce a Content Security Policy (source: Wikipedia) to disable any features that might be manipulated for an XSS attack.\r\n* Read the documentation for any of the libraries referenced in your code to understand which elements allow for embedded HTML.\n\n## Remediation\n\nUpgrade `xerces:xercesimpl` to version 2.10.0 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/apache/xerces2-j/commit/0bdf77af1d4fd26ec2e630fb6d12e2dfa77bc12b)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2009-2625)\n",
            "from": [
              "xerces:xercesImpl@2.6.2"
            ],
            "package": "xerces:xercesImpl",
            "version": "2.6.2",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.10.0)"
              ]
            },
            "publicationTime": 1512393045000,
            "disclosureTime": 1249332644000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2009-2625"
              ],
              "CWE": [
                "CWE-400"
              ]
            },
            "credit": [
              "Jukka Taimisto",
              "Tero Rontti",
              "Rauli Kaksonen"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "xerces:xercesImpl@2.10.0"
            ]
          },
          {
            "id": "SNYK-JAVA-XERCES-31585",
            "url": "https://snyk.io/vuln/SNYK-JAVA-XERCES-31585",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[xerces:xercesImpl](https://mvnrepository.com/artifact/xerces/xercesImpl) is a fully compliant XML parsers in the Apache Xerces family\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nApache Xerces2 Java allows remote attackers to cause a denial of service (CPU consumption) via a crafted message to an XML service, which triggers hash table collisions.\n\n## Remediation\n\nUpgrade `xerces:xercesImpl` to version 2.12.0 or higher.\n\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## References\n\n- [GutHub Commit](https://github.com/apache/xerces2-j/commit/992b5d9c24102ad20330d36c0a71162753a37449)\n\n- [Jira Issue](https://issues.apache.org/jira/browse/XERCESJ-1685?jql=project%20%3D%20XERCESJ)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2012-0881)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=787104)\n",
            "from": [
              "xerces:xercesImpl@2.6.2"
            ],
            "package": "xerces:xercesImpl",
            "version": "2.6.2",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,2.12.0)"
              ]
            },
            "publicationTime": 1510821664000,
            "disclosureTime": 1328220000000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2012-0881"
              ],
              "CWE": [
                "CWE-400"
              ]
            },
            "credit": [
              "Juraj Somorovsky"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "xerces:xercesImpl@2.12.0"
            ]
          },
          {
            "id": "SNYK-JAVA-XERCES-31497",
            "url": "https://snyk.io/vuln/SNYK-JAVA-XERCES-31497",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[xerces:xercesimpl](http://xerces.apache.org) is a that is used for high performance, fully compliant XML parsers in the Apache Xerces family.\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nAn attacker may be able to force the target server to parse an FTP URL, which points to an FTP server controller by the attacker. When the target server is mid way through fetching the FTP resources, the attackers malicious FTP server will exit the process and will leave the thread hanging in the target server.\r\n\r\nIt is possible to conduct this attack only if the following conditions are met:\r\n* An attacker can pass an URL parameter that points to a controlled FTP server to the target.\r\n* Target server uses vulnerable component(s) to fetch the resource specified by the attacker.\r\n* Target server does not prevent fetching of FTP URI resources.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `xerces:xercesimpl` to version 2.11.0 or higher.\n\n\n## References\n\n- [Blog Post](https://blogs.securiteam.com/index.php/archives/3271)\n\n- [Exploit - ExploitDB](https://www.exploit-db.com/exploits/44057)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-10355)\n",
            "from": [
              "xerces:xercesImpl@2.6.2"
            ],
            "package": "xerces:xercesImpl",
            "version": "2.6.2",
            "severity": "medium",
            "exploitMaturity": "proof-of-concept",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.11.0)"
              ]
            },
            "publicationTime": 1504886535000,
            "disclosureTime": 1504047600000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-10355"
              ],
              "CWE": [
                "CWE-400"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L/E:P/RL:O/RC:R",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "xerces:xercesImpl@2.11.0"
            ]
          },
          {
            "id": "SNYK-JAVA-XERCES-30183",
            "url": "https://snyk.io/vuln/SNYK-JAVA-XERCES-30183",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[xerces:xercesimpl](http://xerces.apache.org) is a that is used for high performance, fully compliant XML parsers in the Apache Xerces family.\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS)\nwhich is caused by the way the JRE processes XML files. A remote attacker could use this flaw to supply crafted XML that would lead to a denial of service.\n\n## Remediation\n\nUpgrade `xerces:xercesimpl` to version 2.12.0 or higher.\n\n\n## References\n\n- [Apache-SVN](http://svn.apache.org/viewvc?view=revision&revision=1499506)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/CVE-2013-4002)\n",
            "from": [
              "xerces:xercesImpl@2.6.2"
            ],
            "package": "xerces:xercesImpl",
            "version": "2.6.2",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.12.0)"
              ]
            },
            "publicationTime": 1381855909000,
            "disclosureTime": 1374577380000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2013-4002"
              ],
              "CWE": [
                "CWE-94"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H",
            "cvssScore": 6.5,
            "patches": [],
            "upgradePath": [
              "xerces:xercesImpl@2.12.0"
            ]
          },
          {
            "id": "SNYK-JAVA-TOMCAT-31377",
            "url": "https://snyk.io/vuln/SNYK-JAVA-TOMCAT-31377",
            "title": "Access Restriction Bypass",
            "type": "vuln",
            "description": "## Overview\n\n[tomcat:jasper-runtime](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jasper-runtime%22) is a tomcats JSP parser.\n\n\nAffected versions of this package are vulnerable to Access Restriction Bypass.\nIt was discovered that a malicious web application could bypass a configured SecurityManager via a Tomcat utility method that was accessible to web applications.\n\n## Remediation\n\nThere is no fixed version for `tomcat:jasper-runtime`.\n\n\n## References\n\n- [Exploit DB](https://www.exploit-db.com/exploits/47892)\n\n- [OSS Security](http://seclists.org/oss-sec/2016/q4/259)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat80/commit/11950154730c3b2473580621df83356e09142e73)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat80/commit/3adf2d614bce0fb9587b0eb7a4a9fbb7ac8e6d82)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/492cbc9a1e33e6d356438bcba4fa2b67680d245a)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/648122fef84d3b43223e0b5ae668f84719dada0a)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/865e067f1f513ea0f5b876a89c7b8ff6cefedd7c)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/890a2f681ed2f3461b27983d7da9737375ff2ae4)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/a6b1ebc246b91b854237e5aad3dfd2b5460ea282)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/bc6df47f1a0d8a0e181680ee1b59e0fe45040830)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "tomcat:jasper-runtime@5.5.23"
            ],
            "package": "tomcat:jasper-runtime",
            "version": "5.5.23",
            "severity": "high",
            "exploitMaturity": "proof-of-concept",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "publicationTime": 1477636288000,
            "disclosureTime": 1477636288000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2016-5018"
              ],
              "CWE": [
                "CWE-284"
              ]
            },
            "credit": [
              "Alvaro Munoz"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N/E:P",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-TOMCAT-31376",
            "url": "https://snyk.io/vuln/SNYK-JAVA-TOMCAT-31376",
            "title": "Access Restriction Bypass",
            "type": "vuln",
            "description": "## Overview\n\n[tomcat:jasper-compiler](http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jasper-compiler%22)) is a jasper compiler.\n\n\nAffected versions of this package are vulnerable to Access Restriction Bypass.\nIt was discovered that a malicious web application could bypass a configured SecurityManager via manipulation of the configuration parameters for the JSP Servlet.\n\n## Remediation\n\nThere is no fixed version for `tomcat:jasper-compiler`.\n\n\n## References\n\n- [OSS Security](http://www.openwall.com/lists/oss-security/2016/10/27/11)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat80/commit/66e227e0c73ea2f7e93cee9340b580912d580f5d)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat80/commit/d98fa92b9dfc90fe1ffdaa3cce1be3be84532260)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/1d69a4ddb363ee96b41337495eb7a263f2e01ff7)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/bec54243e09b4a171f0a0672e5d8d3cdb281f926)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/f603f2f4595073f9490e01699d2083112a7c09a7)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/f97769f50ee2613e1bf27107a01d48907fd993ac)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/fb65c5fe6d298195beee11324416a975bea6d701)\n\n- [Possible GitHub Commit](https://github.com/apache/tomcat/commit/ffa0346fba2946401630291b642f1cff66d6a2be)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "tomcat:jasper-compiler@5.5.23"
            ],
            "package": "tomcat:jasper-compiler",
            "version": "5.5.23",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1477640951000,
            "disclosureTime": 1477640951000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2016-6796"
              ],
              "CWE": [
                "CWE-284"
              ]
            },
            "credit": [
              "Apache Tomcat Security Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-ORGMORTBAYJETTY-173762",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGMORTBAYJETTY-173762",
            "title": "Cryptographic Issues",
            "type": "vuln",
            "description": "## Overview\n\n[org.mortbay.jetty:jetty](https://mvnrepository.com/artifact/org.mortbay.jetty/jetty) is a web server and servlet engine.\n\n\nAffected versions of this package are vulnerable to Cryptographic Issues.\nIt computes hash values for form parameters without restricting the ability to trigger hash collisions predictably, which allows remote attackers to cause a denial of service (CPU consumption) by sending many crafted parameters.\n\n\n## Remediation\n\nThere is no fixed version for `org.mortbay.jetty:jetty`.\n\n**Note** This artifact was moved to: `org.eclipse.jetty:jetty-server` which contains a fix for this vulnerability.\n\n## References\n\n- [Github Commit](https://github.com/eclipse/jetty.project/commit/085c79d7d6cfbccc02821ffdb64968593df3e0bf#diff-cf34675e68072d3ca271b52204d06922)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2011-4461)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "org.mortbay.jetty:jetty@6.1.26"
            ],
            "package": "org.mortbay.jetty:jetty",
            "version": "6.1.26",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1431532650000,
            "disclosureTime": 1325210100000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2011-4461"
              ],
              "CWE": [
                "CWE-310"
              ]
            },
            "credit": [
              "Alexander Klink"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMMONSHTTPCLIENT-30083",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMMONSHTTPCLIENT-30083",
            "title": "Improper Certificate Validation",
            "type": "vuln",
            "description": "## Overview\n\n[commons-httpclient:commons-httpclient](https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient) is a HttpClient component of the Apache HttpComponents project.\n\n\nAffected versions of this package are vulnerable to Improper Certificate Validation\ndue to not verifying that the requesting server hostname matches a domain name in the subject's `Common Name (CN)` or `subjectAltName` field of the X.509 certificate. This allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.\n\n## Remediation\n\nThere is no fixed version for `commons-httpclient:commons-httpclient`.\n\n\n## References\n\n- [Jira Issue](https://issues.apache.org/jira/browse/HTTPCLIENT-1265)\n\n- [The University of Texas](http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf)\n\n- [X-Force Vulnerability Report](https://exchange.xforce.ibmcloud.com/vulnerabilities/79984)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "commons-httpclient:commons-httpclient@3.1"
            ],
            "package": "commons-httpclient:commons-httpclient",
            "version": "3.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1364230307000,
            "disclosureTime": 1352069700000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2012-5783"
              ],
              "CWE": [
                "CWE-295"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N",
            "cvssScore": 5.4,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-ORGCODEHAUSJACKSON-534878",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGCODEHAUSJACKSON-534878",
            "title": "XML External Entity (XXE) Injection",
            "type": "vuln",
            "description": "## Overview\n\n[org.codehaus.jackson:jackson-mapper-asl](https://mvnrepository.com/artifact/org.codehaus.jackson/jackson-mapper-asl) is a high-performance data binding package built on Jackson JSON processor.\n\n\nAffected versions of this package are vulnerable to XML External Entity (XXE) Injection.\nMultiple classes including  `XmlMapper` was found to be vulnerabiltiy to XXE, which might allow attackers to have unspecified impact via unknown vectors.\n\n## Details\nXXE Injection is a type of attack against an application that parses XML input.\r\nXML is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. By default, many XML processors allow specification of an external entity, a URI that is dereferenced and evaluated during XML processing. When an XML document is being parsed, the parser can make a request and include the content at the specified URI inside of the XML document.\r\n\r\nAttacks can include disclosing local files, which may contain sensitive data such as passwords or private user data, using file: schemes or relative paths in the system identifier.\r\n\r\nFor example, below is a sample XML document, containing an XML element- username.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n   <username>John</username>\r\n</xml>\r\n```\r\n\r\nAn external XML entity - `xxe`, is defined using a system identifier and present within a DOCTYPE header. These entities can access local or remote content. For example the below code contains an external XML entity that would fetch the content of  `/etc/passwd` and display it to the user rendered by `username`.\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\r\n<!DOCTYPE foo [\r\n   <!ENTITY xxe SYSTEM \"file:///etc/passwd\" >]>\r\n   <username>&xxe;</username>\r\n</xml>\r\n```\r\n\r\nOther XXE Injection attacks can access local resources that may not stop returning data, possibly impacting application availability and leading to Denial of Service.\n\n\n## Remediation\n\nThere is no fixed version for `org.codehaus.jackson:jackson-mapper-asl`.\n\n\n## References\n\n- [Bugzilla Ticket](https://bugzilla.redhat.com/show_bug.cgi?id=1715075)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "org.codehaus.jackson:jackson-mapper-asl@1.5.2"
            ],
            "package": "org.codehaus.jackson:jackson-mapper-asl",
            "version": "1.5.2",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1574164592000,
            "disclosureTime": 1574035200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-10172"
              ],
              "CWE": [
                "CWE-611"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-ORGAPACHEHADOOP-31574",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGAPACHEHADOOP-31574",
            "title": "Cryptographic Weakness",
            "type": "vuln",
            "description": "## Overview\n\n[org.apache.hadoop:hadoop-core](https://hadoop.apache.org) is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models.\n\n\nAffected versions of this package are vulnerable to Cryptographic Weakness\ndue to an insufficient secret key length. The package generates token passwords using a 20-bit secret when Kerberos security features are enabled, which makes it easier for context-dependent attackers to crack secret keys via a brute-force attack.\n\n## Remediation\n\nUpgrade `org.apache.hadoop:hadoop-core` to version 1.0.4 or higher.\n\n\n## References\n\n- [Cloudera Security Bulletin](https://www.cloudera.com/documentation/other/security-bulletins/topics/csb_topic_1.html#topic_1_0)\n\n- [Github Commit](https://github.com/apache/hadoop/commit/d6b7f10438677507fbe1adadec28d219889eab5b)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2"
            ],
            "package": "org.apache.hadoop:hadoop-core",
            "version": "0.20.2-cdh3u2",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,1.0.4)"
              ]
            },
            "publicationTime": 1510197365000,
            "disclosureTime": 1348434000000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2012-4449"
              ],
              "CWE": [
                "CWE-521"
              ]
            },
            "credit": [
              "Daryn Sharp"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "org.apache.hadoop:hadoop-core@1.0.4"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGAPACHEHADOOP-30629",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGAPACHEHADOOP-30629",
            "title": "Improper Authentication",
            "type": "vuln",
            "description": "## Overview\n[`org.apache.hadoop:hadoop-core`](https://hadoop.apache.org)  is a framework that allows for the distributed processing of large data sets across clusters of computers using simple programming models.\n\nThe RPC protocol implementation in Apache Hadoop 2.x before 2.0.6-alpha, 0.23.x before 0.23.9, and 1.x before 1.2.1, when the Kerberos security features are enabled, allows man-in-the-middle attackers to disable bidirectional authentication and obtain sensitive information by forcing a downgrade to simple authentication.\n\n## References\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2013-2192)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2"
            ],
            "package": "org.apache.hadoop:hadoop-core",
            "version": "0.20.2-cdh3u2",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,1.2.1)"
              ]
            },
            "publicationTime": 1402187619000,
            "disclosureTime": 1390589700000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2013-2192"
              ],
              "CWE": [
                "CWE-287"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:A/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",
            "cvssScore": 4.2,
            "patches": [],
            "upgradePath": [
              "org.apache.hadoop:hadoop-core@1.2.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMMONSHTTPCLIENT-31660",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMMONSHTTPCLIENT-31660",
            "title": "Man-in-the-Middle (MitM)",
            "type": "vuln",
            "description": "## Overview\n\n[commons-httpclient:commons-httpclient](https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient) is a HttpClient component of the Apache HttpComponents project.\n\n\nAffected versions of this package are vulnerable to Man-in-the-Middle (MitM).\ndue to not verifing the requesting server's hostname agains existing domain names in the SSL Certificate. The `AbstractVerifier` does not properly verify that the server hostname matches a domain name in the subject's `Common Name (CN)` or `subjectAltName` field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via a certificate with a subject that specifies a common name in a field that is not the CN field.  \r\n\r\n**NOTE:** this issue exists because of an incomplete fix for [CVE-2012-5783](SNYK-JAVA-COMMONSHTTPCLIENT-30083).\n\n## Remediation\n\nThere is no fixed version for `commons-httpclient:commons-httpclient`.\n\n\n## References\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-6153)\n\n- [Possible GitHub Commit](https://github.com/apache/httpcomponents-client/commit/6e14fc146a66e0f3eb362f45f95d1a58ee18886a)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "net.java.dev.jets3t:jets3t@0.6.1",
              "commons-httpclient:commons-httpclient@3.1"
            ],
            "package": "commons-httpclient:commons-httpclient",
            "version": "3.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1523192174000,
            "disclosureTime": 1409853300000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2012-6153"
              ],
              "CWE": [
                "CWE-20"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N",
            "cvssScore": 4.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMMONSHTTPCLIENT-30083",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMMONSHTTPCLIENT-30083",
            "title": "Improper Certificate Validation",
            "type": "vuln",
            "description": "## Overview\n\n[commons-httpclient:commons-httpclient](https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient) is a HttpClient component of the Apache HttpComponents project.\n\n\nAffected versions of this package are vulnerable to Improper Certificate Validation\ndue to not verifying that the requesting server hostname matches a domain name in the subject's `Common Name (CN)` or `subjectAltName` field of the X.509 certificate. This allows man-in-the-middle attackers to spoof SSL servers via an arbitrary valid certificate.\n\n## Remediation\n\nThere is no fixed version for `commons-httpclient:commons-httpclient`.\n\n\n## References\n\n- [Jira Issue](https://issues.apache.org/jira/browse/HTTPCLIENT-1265)\n\n- [The University of Texas](http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf)\n\n- [X-Force Vulnerability Report](https://exchange.xforce.ibmcloud.com/vulnerabilities/79984)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "net.java.dev.jets3t:jets3t@0.6.1",
              "commons-httpclient:commons-httpclient@3.1"
            ],
            "package": "commons-httpclient:commons-httpclient",
            "version": "3.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1364230307000,
            "disclosureTime": 1352069700000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2012-5783"
              ],
              "CWE": [
                "CWE-295"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N",
            "cvssScore": 5.4,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMMONSHTTPCLIENT-31660",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMMONSHTTPCLIENT-31660",
            "title": "Man-in-the-Middle (MitM)",
            "type": "vuln",
            "description": "## Overview\n\n[commons-httpclient:commons-httpclient](https://mvnrepository.com/artifact/commons-httpclient/commons-httpclient) is a HttpClient component of the Apache HttpComponents project.\n\n\nAffected versions of this package are vulnerable to Man-in-the-Middle (MitM).\ndue to not verifing the requesting server's hostname agains existing domain names in the SSL Certificate. The `AbstractVerifier` does not properly verify that the server hostname matches a domain name in the subject's `Common Name (CN)` or `subjectAltName` field of the X.509 certificate, which allows man-in-the-middle attackers to spoof SSL servers via a certificate with a subject that specifies a common name in a field that is not the CN field.  \r\n\r\n**NOTE:** this issue exists because of an incomplete fix for [CVE-2012-5783](SNYK-JAVA-COMMONSHTTPCLIENT-30083).\n\n## Remediation\n\nThere is no fixed version for `commons-httpclient:commons-httpclient`.\n\n\n## References\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-6153)\n\n- [Possible GitHub Commit](https://github.com/apache/httpcomponents-client/commit/6e14fc146a66e0f3eb362f45f95d1a58ee18886a)\n",
            "from": [
              "org.apache.hadoop:hadoop-core@0.20.2-cdh3u2",
              "commons-httpclient:commons-httpclient@3.1"
            ],
            "package": "commons-httpclient:commons-httpclient",
            "version": "3.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1523192174000,
            "disclosureTime": 1409853300000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2012-6153"
              ],
              "CWE": [
                "CWE-20"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N",
            "cvssScore": 4.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          },
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 41,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "31c1575a-43e8-4dfa-8151-e7ff1f25506d",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "title": "Timing Attack",
            "type": "vuln",
            "description": "## Overview\r\n[org.eclipse.jetty:jetty-util](https://github.com/eclipse/jetty.project)  is a lightweight highly scalable java based web server and servlet engine.\r\n\r\nAffected versions of this package are vulnerable to Timing Attacks. A flaw in the `util/security/Password.java` class makes it easier for remote attackers to obtain access by observing elapsed times before rejection of incorrect passwords.\r\n\r\n## Remediation\r\nUpgrade `org.eclipse.jetty:jetty-util` to versions 9.2.22, 9.3.20, 9.4.6 or higher.\r\n\r\n## References\r\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-9735)\r\n- [GitHub Issue](https://github.com/eclipse/jetty.project/issues/1556)",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-http@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-io@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-util@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-util",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.2.22.v20170606)",
                "[9.3.0.M0, 9.3.20.v20170531)",
                "[9.4.0.M0, 9.4.6.v20170531)"
              ]
            },
            "publicationTime": 1522742847000,
            "disclosureTime": 1497648540000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-9735"
              ],
              "CWE": [
                "CWE-200"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-servlet@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-security@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-server@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-http@9.0.0.v20130308"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32383",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32383",
            "title": "Cache Poisoning",
            "type": "vuln",
            "description": "## Overview\n\n[org.eclipse.jetty:jetty-http](https://github.com/eclipse/jetty.project) is a is a http module for jetty server.\n\n\nAffected versions of this package are vulnerable to Cache Poisoning.\nAn `HTTP/1` style request line (i.e. method space URI space version) that declares a version of `HTTP/0.9` was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version, the response sent could be interpreted by the intermediary as `HTTP/1` headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response.\n\n## Remediation\n\nUpgrade `org.eclipse.jetty:jetty-http` to version 9.3.24.v20180605, 9.4.11.v20180605 or higher.\n\n\n## References\n\n- [Eclipse Bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=535667)\n\n- [GitHub Commit](https://github.com/eclipse/jetty.project/commit/a285deea42fcab60d9edcf994e458c238a348b55)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-7656)\n",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-http@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-http",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.3.24.v20180605)",
                "[9.4.0.M0,9.4.11.v20180605)"
              ]
            },
            "publicationTime": 1530197950000,
            "disclosureTime": 1528374680000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7656"
              ],
              "CWE": [
                "CWE-444"
              ]
            },
            "credit": [
              "Regis Leroy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-servlet@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-security@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-server@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-http@9.3.24.v20180605"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "title": "Timing Attack",
            "type": "vuln",
            "description": "## Overview\r\n[org.eclipse.jetty:jetty-util](https://github.com/eclipse/jetty.project)  is a lightweight highly scalable java based web server and servlet engine.\r\n\r\nAffected versions of this package are vulnerable to Timing Attacks. A flaw in the `util/security/Password.java` class makes it easier for remote attackers to obtain access by observing elapsed times before rejection of incorrect passwords.\r\n\r\n## Remediation\r\nUpgrade `org.eclipse.jetty:jetty-util` to versions 9.2.22, 9.3.20, 9.4.6 or higher.\r\n\r\n## References\r\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-9735)\r\n- [GitHub Issue](https://github.com/eclipse/jetty.project/issues/1556)",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-xml@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-util@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-util",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.2.22.v20170606)",
                "[9.3.0.M0, 9.3.20.v20170531)",
                "[9.4.0.M0, 9.4.6.v20170531)"
              ]
            },
            "publicationTime": 1522742847000,
            "disclosureTime": 1497648540000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-9735"
              ],
              "CWE": [
                "CWE-200"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.2.22.v20170606",
              "org.eclipse.jetty:jetty-xml@9.2.22.v20170606",
              "org.eclipse.jetty:jetty-util@9.2.22.v20170606"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-460763",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-460763",
            "title": "Cache Poisoning",
            "type": "vuln",
            "description": "## Overview\n\n[org.eclipse.jetty:jetty-server](https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-server) is a lightweight highly scalable java based web server and servlet engine.\n\n\nAffected versions of this package are vulnerable to Cache Poisoning.\nAn `HTTP/1` style request line (i.e. method space URI space version) that declares a version of `HTTP/0.9` was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version, the response sent could be interpreted by the intermediary as `HTTP/1` headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response.\n\n## Remediation\n\nUpgrade `org.eclipse.jetty:jetty-server` to version 9.3.24.v20180605, 9.4.11.v20180605 or higher.\n\n\n## References\n\n- [Eclipse Bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=535667)\n\n- [GitHub Commit](https://github.com/eclipse/jetty.project/commit/a285deea42fcab60d9edcf994e458c238a348b55)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-7656)\n",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-server",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.3.24.v20180605)",
                "[9.4.0.M0,9.4.11.v20180605)"
              ]
            },
            "publicationTime": 1530197950000,
            "disclosureTime": 1528374680000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7656"
              ],
              "CWE": [
                "CWE-444"
              ]
            },
            "credit": [
              "Regis Leroy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-servlet@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-security@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-server@9.3.24.v20180605"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32385",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32385",
            "title": "Authorization Bypass",
            "type": "vuln",
            "description": "## Overview\r\n[org.eclipse.jetty:jetty-server](https://github.com/eclipse/jetty.project) is a lightweight highly scalable java based web server and servlet engine.\r\n\r\nAffected versions of this package are vulnerable to Authorization Bypass. When it presented with two content-lengths headers, Jetty ignored the second. When presented with a content-length and a chunked encoding header, the content-length was ignored (as per RFC 2616). If an intermediary decided on the shorter length, but still passed on the longer body, then body content could be interpreted by Jetty as a pipelined request. If the intermediary was imposing authorization, the fake pipelined request would bypass that authorization.\r\n\r\n## Remediation\r\nUpgrade `org.eclipse.jetty:jetty-server` to versions  9.2.25, 9.3.24, 9.4.11 or higher.\r\n\r\n## References\r\n- [Eclipse Bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=535669)\r\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-7658)",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-server",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.2.25.v20180606)",
                "[9.3.0.M0, 9.3.24.v20180605)",
                "[9.4.0.M0, 9.4.11.v20180605)"
              ]
            },
            "publicationTime": 1530197950000,
            "disclosureTime": 1528288280000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7658"
              ],
              "CWE": [
                "CWE-444"
              ]
            },
            "credit": [
              "Regis Leroy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.2.25.v20180606",
              "org.eclipse.jetty:jetty-servlet@9.2.25.v20180606",
              "org.eclipse.jetty:jetty-security@9.2.25.v20180606",
              "org.eclipse.jetty:jetty-server@9.2.25.v20180606"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6",
              "ch.qos.logback:logback-core@1.0.6"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "1.0.6",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "1.0.6",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-174560",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-174560",
            "title": "Information Exposure",
            "type": "vuln",
            "description": "## Overview\n\n[org.eclipse.jetty:jetty-server](https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-server) is a lightweight highly scalable java based web server and servlet engine.\n\n\nAffected versions of this package are vulnerable to Information Exposure.\nThe configuration of a Jetty server may be leaked as part of a HTTP 404 response. This is due to the `DefaultHandler` class producing an error page during an exception.\n\n## Remediation\n\nUpgrade `org.eclipse.jetty:jetty-server` to version 9.2.28.v20190418, 9.3.27.v20190418, 9.4.17.v20190418 or higher.\n\n\n## References\n\n- [Eclipse Report](https://bugs.eclipse.org/bugs/show_bug.cgi?id=546577)\n\n- [GitHub Commit](https://github.com/eclipse/jetty.project/commit/04c994712c0b29824633598cfe0bf709f3b96f09)\n\n- [GitHub Issue](https://github.com/eclipse/jetty.project/issues/3555)\n",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-server",
            "version": "8.1.5.v20120716",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[7.0.0.M0,9.2.28.v20190418)",
                "[9.3.0.M0,9.3.27.v20190418)",
                "[9.4.0.M0,9.4.17.v20190418)"
              ]
            },
            "publicationTime": 1555967337000,
            "disclosureTime": 1555967337000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-10247"
              ],
              "CWE": [
                "CWE-213"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.2.28.v20190418",
              "org.eclipse.jetty:jetty-servlet@9.2.28.v20190418",
              "org.eclipse.jetty:jetty-security@9.2.28.v20190418",
              "org.eclipse.jetty:jetty-server@9.2.28.v20190418"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "1.0.6",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6",
              "ch.qos.logback:logback-core@1.0.6"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "1.0.6",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 20,
      "packageManager": "sbt"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "9f952bf8-b759-4065-a091-55faf62b1fb2",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 19,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "e24e2353-68ef-4a15-881b-7a9e1aa87b68",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:alignment@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:alignment",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 5,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "ec0e6782-7698-4650-ad9c-3b6b67221e9b",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 13,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "f3d223b4-bf7d-4e9c-9555-14c3e5aa1bec",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:alignment@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:alignment",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 6,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "696599da-c85a-4358-8a3e-8c6cf5492327",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@r09"
            ],
            "package": "com.google.guava:guava",
            "version": "r09",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@10.0"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "title": "Unsafe Dependancy Resolution",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.module:jackson-module-scala](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-scala) is an Add-on module for Jackson (http://wiki.fasterxml.com/JacksonHome) to support Scala-specific datatypes.\n\n\nAffected versions of this package are vulnerable to Unsafe Dependancy Resolution\ndue to resolving dependencies over an insecure channel (http).\r\n\r\nIf the build occurred over an insecure connection, a malicious user could have perform a Man-in-the-Middle attack during the build and alter the build artifacts that were produced.\r\nIn case that any of these artifacts were compromised, any developers using these could be altered.\r\n \r\n**Note:** In order to validate that this artifact was not compromised, the maintainer would need to confirm that none of the artifacts published to the registry were not altered with. Until this happens, we can not guarantee that this artifact was not compromised even though the probability that this happened is low. \r\n\r\nWe have chosen to alert on this issue when maintainers either decided to issue CVEs themselves, or in cases when maintainers decided against performing audits on there build to verify they had not been compromised.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.module:jackson-module-scala` to version 2.9.9 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-module-scala/pull/406/commits/a2d13cea104ee790759519ade6f2f688791e8198)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-module-scala/issues/400)\n\n- [Jonathan Leitschuh's Blog](https://medium.com/@jonathan.leitschuh/1fc329d898fb)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0"
            ],
            "package": "com.fasterxml.jackson.module:jackson-module-scala",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.9)"
              ]
            },
            "publicationTime": 1560253122000,
            "disclosureTime": 1550838955000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-494",
                "CWE-829"
              ]
            },
            "credit": [
              "JLLeitschuh"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 5.6,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          }
        ],
        "licenses": []
      },
      "dependencyCount": 18,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "860b4f36-05e5-4eb3-adb4-13f32dfc4a4d",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "npm:negotiator:20160616",
            "url": "https://snyk.io/vuln/npm:negotiator:20160616",
            "title": "Regular Expression Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[negotiator](https://npmjs.org/package/negotiator) is an HTTP content negotiator for Node.js.\n\n\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (DoS)\nwhen parsing `Accept-Language` http header.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\n\n## Remediation\n\nUpgrade `negotiator` to version 0.6.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/jshttp/negotiator/commit/26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c)\n\n- [OSWAP Advisory](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "compression@1.5.2",
              "accepts@1.2.13",
              "negotiator@0.5.3"
            ],
            "package": "negotiator",
            "version": "0.5.3",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.6.1"
              ]
            },
            "publicationTime": 1466098566000,
            "disclosureTime": 1466098566000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2016-10539"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-NEGOTIATOR-10104"
              ]
            },
            "credit": [
              "Adam Baldwin"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [
              {
                "id": "patch:npm:negotiator:20160616:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_3_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "0.1.0",
                "comments": [],
                "modificationTime": 1575373245832
              },
              {
                "id": "patch:npm:negotiator:20160616:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_2_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "<= 0.4.7 > 0.1.0",
                "comments": [],
                "modificationTime": 1575373245831
              },
              {
                "id": "patch:npm:negotiator:20160616:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_1_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "<= 0.5.3 > 0.4.7",
                "comments": [],
                "modificationTime": 1575373245830
              },
              {
                "id": "patch:npm:negotiator:20160616:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_0_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "0.6.0",
                "comments": [],
                "modificationTime": 1575373245829
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:negotiator:20160616",
            "url": "https://snyk.io/vuln/npm:negotiator:20160616",
            "title": "Regular Expression Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[negotiator](https://npmjs.org/package/negotiator) is an HTTP content negotiator for Node.js.\n\n\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (DoS)\nwhen parsing `Accept-Language` http header.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\n\n## Remediation\n\nUpgrade `negotiator` to version 0.6.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/jshttp/negotiator/commit/26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c)\n\n- [OSWAP Advisory](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-index@1.7.3",
              "accepts@1.2.13",
              "negotiator@0.5.3"
            ],
            "package": "negotiator",
            "version": "0.5.3",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.6.1"
              ]
            },
            "publicationTime": 1466098566000,
            "disclosureTime": 1466098566000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2016-10539"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-NEGOTIATOR-10104"
              ]
            },
            "credit": [
              "Adam Baldwin"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [
              {
                "id": "patch:npm:negotiator:20160616:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_3_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "0.1.0",
                "comments": [],
                "modificationTime": 1575373245832
              },
              {
                "id": "patch:npm:negotiator:20160616:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_2_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "<= 0.4.7 > 0.1.0",
                "comments": [],
                "modificationTime": 1575373245831
              },
              {
                "id": "patch:npm:negotiator:20160616:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_1_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "<= 0.5.3 > 0.4.7",
                "comments": [],
                "modificationTime": 1575373245830
              },
              {
                "id": "patch:npm:negotiator:20160616:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/negotiator/20160616/negotiator_20160616_0_0_26a05ec15cf7d1fa56000d66ebe9c9a1a62cb75c.patch"
                ],
                "version": "0.6.0",
                "comments": [],
                "modificationTime": 1575373245829
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:qs:20170213",
            "url": "https://snyk.io/vuln/npm:qs:20170213",
            "title": "Prototype Override Protection Bypass",
            "type": "vuln",
            "description": "## Overview\n\n[qs](https://www.npmjs.com/package/qs) is a querystring parser that supports nesting and arrays, with a depth limit.\n\n\nAffected versions of this package are vulnerable to Prototype Override Protection Bypass.\nBy default `qs` protects against attacks that attempt to overwrite an object's existing prototype properties, such as `toString()`, `hasOwnProperty()`,etc.\r\n\r\nFrom [`qs` documentation](https://github.com/ljharb/qs):\r\n> By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use plainObjects as mentioned above, or set allowPrototypes to true which will allow user input to overwrite those properties. WARNING It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.\r\n\r\nOverwriting these properties can impact application logic, potentially allowing attackers to work around security controls, modify data, make the application unstable and more.\r\n\r\nIn versions of the package affected by this vulnerability, it is possible to circumvent this protection and overwrite prototype properties and functions by prefixing the name of the parameter with `[` or `]`. e.g. `qs.parse(\"]=toString\")` will return `{toString = true}`, as a result, calling `toString()` on the object will throw an exception.\r\n\r\n**Example:**\r\n```js\r\nqs.parse('toString=foo', { allowPrototypes: false })\r\n// {}\r\n\r\nqs.parse(\"]=toString\", { allowPrototypes: false })\r\n// {toString = true} <== prototype overwritten\r\n```\r\n\r\nFor more information, you can check out our [blog](https://snyk.io/blog/high-severity-vulnerability-qs/).\r\n\r\n## Disclosure Timeline\r\n- February 13th, 2017 - Reported the issue to package owner.\r\n- February 13th, 2017 - Issue acknowledged by package owner.\r\n- February 16th, 2017 - Partial fix released in versions `6.0.3`, `6.1.1`, `6.2.2`, `6.3.1`.\r\n- March 6th, 2017     - Final fix released in versions `6.4.0`,`6.3.2`, `6.2.3`, `6.1.2` and `6.0.4`\n\n## Remediation\n\nUpgrade `qs` to version 6.0.4, 6.1.2, 6.2.3, 6.3.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/ljharb/qs/commit/beade029171b8cef9cee0d03ebe577e2dd84976d)\n\n- [Report of an insufficient fix](https://github.com/ljharb/qs/issues/200)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "body-parser@1.13.3",
              "qs@4.0.0"
            ],
            "package": "qs",
            "version": "4.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<6.0.4",
                ">=6.1.0 <6.1.2",
                ">=6.2.0 <6.2.3",
                ">=6.3.0 <6.3.2"
              ]
            },
            "publicationTime": 1488362454000,
            "disclosureTime": 1486944000000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-1000048"
              ],
              "CWE": [
                "CWE-20"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-QS-10407"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [
              {
                "id": "patch:npm:qs:20170213:7",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/603_604.patch"
                ],
                "version": "=6.0.3",
                "comments": [],
                "modificationTime": 1575373245862
              },
              {
                "id": "patch:npm:qs:20170213:6",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/602_604.patch"
                ],
                "version": "=6.0.2",
                "comments": [],
                "modificationTime": 1575373245861
              },
              {
                "id": "patch:npm:qs:20170213:5",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/611_612.patch"
                ],
                "version": "=6.1.1",
                "comments": [],
                "modificationTime": 1575373245860
              },
              {
                "id": "patch:npm:qs:20170213:4",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/610_612.patch"
                ],
                "version": "=6.1.0",
                "comments": [],
                "modificationTime": 1575373245859
              },
              {
                "id": "patch:npm:qs:20170213:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/622_623.patch"
                ],
                "version": "=6.2.2",
                "comments": [],
                "modificationTime": 1575373245858
              },
              {
                "id": "patch:npm:qs:20170213:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/621_623.patch"
                ],
                "version": "=6.2.1",
                "comments": [],
                "modificationTime": 1575373245857
              },
              {
                "id": "patch:npm:qs:20170213:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/631_632.patch"
                ],
                "version": "=6.3.1",
                "comments": [],
                "modificationTime": 1575373245856
              },
              {
                "id": "patch:npm:qs:20170213:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/630_632.patch"
                ],
                "version": "=6.3.0",
                "comments": [],
                "modificationTime": 1575373245855
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:qs:20170213",
            "url": "https://snyk.io/vuln/npm:qs:20170213",
            "title": "Prototype Override Protection Bypass",
            "type": "vuln",
            "description": "## Overview\n\n[qs](https://www.npmjs.com/package/qs) is a querystring parser that supports nesting and arrays, with a depth limit.\n\n\nAffected versions of this package are vulnerable to Prototype Override Protection Bypass.\nBy default `qs` protects against attacks that attempt to overwrite an object's existing prototype properties, such as `toString()`, `hasOwnProperty()`,etc.\r\n\r\nFrom [`qs` documentation](https://github.com/ljharb/qs):\r\n> By default parameters that would overwrite properties on the object prototype are ignored, if you wish to keep the data from those fields either use plainObjects as mentioned above, or set allowPrototypes to true which will allow user input to overwrite those properties. WARNING It is generally a bad idea to enable this option as it can cause problems when attempting to use the properties that have been overwritten. Always be careful with this option.\r\n\r\nOverwriting these properties can impact application logic, potentially allowing attackers to work around security controls, modify data, make the application unstable and more.\r\n\r\nIn versions of the package affected by this vulnerability, it is possible to circumvent this protection and overwrite prototype properties and functions by prefixing the name of the parameter with `[` or `]`. e.g. `qs.parse(\"]=toString\")` will return `{toString = true}`, as a result, calling `toString()` on the object will throw an exception.\r\n\r\n**Example:**\r\n```js\r\nqs.parse('toString=foo', { allowPrototypes: false })\r\n// {}\r\n\r\nqs.parse(\"]=toString\", { allowPrototypes: false })\r\n// {toString = true} <== prototype overwritten\r\n```\r\n\r\nFor more information, you can check out our [blog](https://snyk.io/blog/high-severity-vulnerability-qs/).\r\n\r\n## Disclosure Timeline\r\n- February 13th, 2017 - Reported the issue to package owner.\r\n- February 13th, 2017 - Issue acknowledged by package owner.\r\n- February 16th, 2017 - Partial fix released in versions `6.0.3`, `6.1.1`, `6.2.2`, `6.3.1`.\r\n- March 6th, 2017     - Final fix released in versions `6.4.0`,`6.3.2`, `6.2.3`, `6.1.2` and `6.0.4`\n\n## Remediation\n\nUpgrade `qs` to version 6.0.4, 6.1.2, 6.2.3, 6.3.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/ljharb/qs/commit/beade029171b8cef9cee0d03ebe577e2dd84976d)\n\n- [Report of an insufficient fix](https://github.com/ljharb/qs/issues/200)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "qs@4.0.0"
            ],
            "package": "qs",
            "version": "4.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<6.0.4",
                ">=6.1.0 <6.1.2",
                ">=6.2.0 <6.2.3",
                ">=6.3.0 <6.3.2"
              ]
            },
            "publicationTime": 1488362454000,
            "disclosureTime": 1486944000000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-1000048"
              ],
              "CWE": [
                "CWE-20"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-QS-10407"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [
              {
                "id": "patch:npm:qs:20170213:7",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/603_604.patch"
                ],
                "version": "=6.0.3",
                "comments": [],
                "modificationTime": 1575373245862
              },
              {
                "id": "patch:npm:qs:20170213:6",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/602_604.patch"
                ],
                "version": "=6.0.2",
                "comments": [],
                "modificationTime": 1575373245861
              },
              {
                "id": "patch:npm:qs:20170213:5",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/611_612.patch"
                ],
                "version": "=6.1.1",
                "comments": [],
                "modificationTime": 1575373245860
              },
              {
                "id": "patch:npm:qs:20170213:4",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/610_612.patch"
                ],
                "version": "=6.1.0",
                "comments": [],
                "modificationTime": 1575373245859
              },
              {
                "id": "patch:npm:qs:20170213:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/622_623.patch"
                ],
                "version": "=6.2.2",
                "comments": [],
                "modificationTime": 1575373245858
              },
              {
                "id": "patch:npm:qs:20170213:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/621_623.patch"
                ],
                "version": "=6.2.1",
                "comments": [],
                "modificationTime": 1575373245857
              },
              {
                "id": "patch:npm:qs:20170213:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/631_632.patch"
                ],
                "version": "=6.3.1",
                "comments": [],
                "modificationTime": 1575373245856
              },
              {
                "id": "patch:npm:qs:20170213:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/qs/20170213/630_632.patch"
                ],
                "version": "=6.3.0",
                "comments": [],
                "modificationTime": 1575373245855
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-favicon@2.3.2",
              "ms@0.7.2"
            ],
            "package": "ms",
            "version": "0.7.2",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-static@1.10.3",
              "send@0.13.2",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-static@1.10.3",
              "send@0.13.2",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-index@1.7.3",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "morgan@1.6.1",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "finalhandler@0.4.0",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "express-session@1.11.3",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "connect-timeout@1.6.2",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "compression@1.5.2",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "body-parser@1.13.3",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "send@0.13.0",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.15.3",
              "send@0.15.3",
              "debug@2.6.7",
              "ms@2.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "connect-timeout@1.6.2",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "debug@2.2.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.15.3",
              "debug@2.6.7",
              "ms@2.0.0"
            ]
          },
          {
            "id": "npm:ms:20170412",
            "url": "https://snyk.io/vuln/npm:ms:20170412",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`ms`](https://www.npmjs.com/package/ms) is a tiny millisecond conversion utility.\r\n\r\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS) due to an incomplete fix for previously reported vulnerability [npm:ms:20151024](https://snyk.io/vuln/npm:ms:20151024). The fix limited the length of accepted input string to 10,000 characters, and turned to be insufficient making it possible to block the event loop for 0.3 seconds (on a typical laptop) with a specially crafted string passed to `ms()` function.\r\n\r\n*Proof of concept*\r\n```js\r\nms = require('ms');\r\nms('1'.repeat(9998) + 'Q') // Takes about ~0.3s\r\n```\r\n\r\n**Note:** Snyk's patch for this vulnerability limits input length to 100 characters. This new limit was deemed to be a breaking change by the author.\r\nBased on user feedback, we believe the risk of breakage is _very_ low, while the value to your security is much greater, and therefore opted to still capture this change in a patch for earlier versions as well.  Whenever patching security issues, we always suggest to run tests on your code to validate that nothing has been broken.\r\n\r\nFor more information on `Regular Expression Denial of Service (ReDoS)` attacks, go to our [blog](https://snyk.io/blog/redos-and-catastrophic-backtracking/).\r\n\r\n## Disclosure Timeline\r\n- Feb 9th, 2017 - Reported the issue to package owner.\r\n- Feb 11th, 2017 - Issue acknowledged by package owner.\r\n- April 12th, 2017 - Fix PR opened by Snyk Security Team.\r\n- May 15th, 2017 - Vulnerability published.\r\n- May 16th, 2017 - Issue fixed and version `2.0.0` released.\r\n- May 21th, 2017 - Patches released for versions `>=0.7.1, <=1.0.0`.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `ms` to version 2.0.0 or higher.\r\n\r\n## References\r\n- [GitHub PR](https://github.com/zeit/ms/pull/89)\r\n- [GitHub Commit](https://github.com/zeit/ms/pull/89/commits/305f2ddcd4eff7cc7c518aca6bb2b2d2daad8fef)",
            "from": [
              "express@3.21.2",
              "send@0.13.0",
              "ms@0.7.1"
            ],
            "package": "ms",
            "version": "0.7.1",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=0.7.1 <2.0.0"
              ]
            },
            "publicationTime": 1494828165000,
            "disclosureTime": 1491944400000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MS-10509"
              ]
            },
            "credit": [
              "Snyk Security Research Team"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:ms:20170412:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_071.patch"
                ],
                "version": "=0.7.1",
                "comments": [],
                "modificationTime": 1575373245866
              },
              {
                "id": "patch:npm:ms:20170412:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_072-073.patch"
                ],
                "version": "=0.7.2 || =0.7.3",
                "comments": [],
                "modificationTime": 1575373245865
              },
              {
                "id": "patch:npm:ms:20170412:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/ms/20170412/ms_100.patch"
                ],
                "version": "=1.0.0",
                "comments": [],
                "modificationTime": 1575373245863
              }
            ],
            "upgradePath": [
              "express@4.15.3",
              "send@0.15.3",
              "ms@2.0.0"
            ]
          },
          {
            "id": "npm:mime:20170907",
            "url": "https://snyk.io/vuln/npm:mime:20170907",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\n\n[mime](https://www.npmjs.com/package/mime) is a comprehensive, compact MIME type module.\n\n\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS).\nIt uses regex the following regex `/.*[\\.\\/\\\\]/` in its lookup, which can cause a slowdown of 2 seconds for 50k characters.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\n\n## Remediation\n\nUpgrade `mime` to version 1.4.1, 2.0.3 or higher.\n\n\n## References\n\n- [Github Commit 1.x](https://github.com/broofa/node-mime/commit/855d0c4b8b22e4a80b9401a81f2872058eae274d)\n\n- [Github Commit 2.0.x](https://github.com/broofa/node-mime/commit/1df903fdeb9ae7eaa048795b8d580ce2c98f40b0)\n\n- [Github Issue](https://github.com/broofa/node-mime/issues/167)\n\n- [NPM Security Advisory](https://www.npmjs.com/advisories/535)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-static@1.10.3",
              "send@0.13.2",
              "mime@1.3.4"
            ],
            "package": "mime",
            "version": "1.3.4",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<1.4.1",
                ">=2.0.0 <2.0.3"
              ]
            },
            "publicationTime": 1506491320000,
            "disclosureTime": 1504818000000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16138"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MIME-10788"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:mime:20170907:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/mime/20170907/mime_20170907_0_0_855d0c4b8b22e4a80b9401a81f2872058eae274d.patch"
                ],
                "version": "=1.2.11 || =1.3.4",
                "comments": [],
                "modificationTime": 1575373245877
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:mime:20170907",
            "url": "https://snyk.io/vuln/npm:mime:20170907",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\n\n[mime](https://www.npmjs.com/package/mime) is a comprehensive, compact MIME type module.\n\n\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS).\nIt uses regex the following regex `/.*[\\.\\/\\\\]/` in its lookup, which can cause a slowdown of 2 seconds for 50k characters.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\n\n## Remediation\n\nUpgrade `mime` to version 1.4.1, 2.0.3 or higher.\n\n\n## References\n\n- [Github Commit 1.x](https://github.com/broofa/node-mime/commit/855d0c4b8b22e4a80b9401a81f2872058eae274d)\n\n- [Github Commit 2.0.x](https://github.com/broofa/node-mime/commit/1df903fdeb9ae7eaa048795b8d580ce2c98f40b0)\n\n- [Github Issue](https://github.com/broofa/node-mime/issues/167)\n\n- [NPM Security Advisory](https://www.npmjs.com/advisories/535)\n",
            "from": [
              "express@3.21.2",
              "send@0.13.0",
              "mime@1.3.4"
            ],
            "package": "mime",
            "version": "1.3.4",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<1.4.1",
                ">=2.0.0 <2.0.3"
              ]
            },
            "publicationTime": 1506491320000,
            "disclosureTime": 1504818000000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16138"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MIME-10788"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:mime:20170907:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/mime/20170907/mime_20170907_0_0_855d0c4b8b22e4a80b9401a81f2872058eae274d.patch"
                ],
                "version": "=1.2.11 || =1.3.4",
                "comments": [],
                "modificationTime": 1575373245877
              }
            ],
            "upgradePath": [
              "express@4.16.0",
              "send@0.16.0",
              "mime@1.4.1"
            ]
          },
          {
            "id": "npm:fresh:20170908",
            "url": "https://snyk.io/vuln/npm:fresh:20170908",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`fresh`](https://www.npmjs.com/package/fresh) is HTTP response freshness testing.\r\n\r\nAffected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks. A Regular Expression (`/ *, */`) was used for parsing HTTP headers and take about 2 seconds matching time for 50k characters.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `fresh` to version 0.5.2 or higher.\n\n## References\n- [Github Commit](https://github.com/jshttp/fresh/commit/21a0f0c2a5f447e0d40bc16be0c23fa98a7b46ec)\n- [Github Issue](https://github.com/jshttp/fresh/issues/24)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-static@1.10.3",
              "send@0.13.2",
              "fresh@0.3.0"
            ],
            "package": "fresh",
            "version": "0.3.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.5.2"
              ]
            },
            "publicationTime": 1506502129000,
            "disclosureTime": 1504904400000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16119"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-FRESH-10791"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:fresh:20170908",
            "url": "https://snyk.io/vuln/npm:fresh:20170908",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`fresh`](https://www.npmjs.com/package/fresh) is HTTP response freshness testing.\r\n\r\nAffected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks. A Regular Expression (`/ *, */`) was used for parsing HTTP headers and take about 2 seconds matching time for 50k characters.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `fresh` to version 0.5.2 or higher.\n\n## References\n- [Github Commit](https://github.com/jshttp/fresh/commit/21a0f0c2a5f447e0d40bc16be0c23fa98a7b46ec)\n- [Github Issue](https://github.com/jshttp/fresh/issues/24)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-favicon@2.3.2",
              "fresh@0.3.0"
            ],
            "package": "fresh",
            "version": "0.3.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.5.2"
              ]
            },
            "publicationTime": 1506502129000,
            "disclosureTime": 1504904400000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16119"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-FRESH-10791"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:fresh:20170908",
            "url": "https://snyk.io/vuln/npm:fresh:20170908",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`fresh`](https://www.npmjs.com/package/fresh) is HTTP response freshness testing.\r\n\r\nAffected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks. A Regular Expression (`/ *, */`) was used for parsing HTTP headers and take about 2 seconds matching time for 50k characters.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `fresh` to version 0.5.2 or higher.\n\n## References\n- [Github Commit](https://github.com/jshttp/fresh/commit/21a0f0c2a5f447e0d40bc16be0c23fa98a7b46ec)\n- [Github Issue](https://github.com/jshttp/fresh/issues/24)\n",
            "from": [
              "express@3.21.2",
              "send@0.13.0",
              "fresh@0.3.0"
            ],
            "package": "fresh",
            "version": "0.3.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.5.2"
              ]
            },
            "publicationTime": 1506502129000,
            "disclosureTime": 1504904400000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16119"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-FRESH-10791"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "express@4.15.5",
              "send@0.15.6",
              "fresh@0.5.2"
            ]
          },
          {
            "id": "npm:fresh:20170908",
            "url": "https://snyk.io/vuln/npm:fresh:20170908",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`fresh`](https://www.npmjs.com/package/fresh) is HTTP response freshness testing.\r\n\r\nAffected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks. A Regular Expression (`/ *, */`) was used for parsing HTTP headers and take about 2 seconds matching time for 50k characters.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `fresh` to version 0.5.2 or higher.\n\n## References\n- [Github Commit](https://github.com/jshttp/fresh/commit/21a0f0c2a5f447e0d40bc16be0c23fa98a7b46ec)\n- [Github Issue](https://github.com/jshttp/fresh/issues/24)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "fresh@0.3.0"
            ],
            "package": "fresh",
            "version": "0.3.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.5.2"
              ]
            },
            "publicationTime": 1506502129000,
            "disclosureTime": 1504904400000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16119"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-FRESH-10791"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:fresh:20170908",
            "url": "https://snyk.io/vuln/npm:fresh:20170908",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`fresh`](https://www.npmjs.com/package/fresh) is HTTP response freshness testing.\r\n\r\nAffected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks. A Regular Expression (`/ *, */`) was used for parsing HTTP headers and take about 2 seconds matching time for 50k characters.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `fresh` to version 0.5.2 or higher.\n\n## References\n- [Github Commit](https://github.com/jshttp/fresh/commit/21a0f0c2a5f447e0d40bc16be0c23fa98a7b46ec)\n- [Github Issue](https://github.com/jshttp/fresh/issues/24)\n",
            "from": [
              "express@3.21.2",
              "fresh@0.3.0"
            ],
            "package": "fresh",
            "version": "0.3.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<0.5.2"
              ]
            },
            "publicationTime": 1506502129000,
            "disclosureTime": 1504904400000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16119"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-FRESH-10791"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "express@4.15.5",
              "fresh@0.5.2"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-static@1.10.3",
              "send@0.13.2",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "serve-index@1.7.3",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "morgan@1.6.1",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "connect-timeout@1.6.2",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "express-session@1.11.3",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "finalhandler@0.4.0",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "compression@1.5.2",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "body-parser@1.13.3",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "send@0.13.0",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.15.5",
              "send@0.15.6",
              "debug@2.6.9"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "npm:debug:20170905",
            "url": "https://snyk.io/vuln/npm:debug:20170905",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\r\n[`debug`](https://www.npmjs.com/package/debug) is a JavaScript debugging utility modelled after Node.js core's debugging technique..\r\n\r\n`debug` uses [printf-style](https://wikipedia.org/wiki/Printf_format_string) formatting. Affected versions of this package are vulnerable to Regular expression Denial of Service (ReDoS) attacks via the the `%o` formatter (Pretty-print an Object all on a single line). It used a regular expression (`/\\s*\\n\\s*/g`) in order to strip whitespaces and replace newlines with spaces, in order to join the data into a single line. This can cause a very low impact of about 2 seconds matching time for data 50k characters long.\r\n\r\n## Details\r\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\r\n\r\n\r\n## Remediation\r\nUpgrade `debug` to version 2.6.9, 3.1.0 or higher.\r\n\r\n## References\r\n- [GitHub Issue](https://github.com/visionmedia/debug/issues/501)\r\n- [GitHub PR](https://github.com/visionmedia/debug/pull/504)",
            "from": [
              "express@3.21.2",
              "debug@2.2.0"
            ],
            "package": "debug",
            "version": "2.2.0",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                ">=1.0.0 <2.6.9",
                ">=3.0.0 <3.1.0"
              ]
            },
            "publicationTime": 1506398105000,
            "disclosureTime": 1504645200000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16137"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-DEBUG-10762"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:debug:20170905:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_0_c38a0166c266a679c8de012d4eaccec3f944e685.patch"
                ],
                "version": ">= 3.0.0 <=3.0.1",
                "comments": [],
                "modificationTime": 1575373245872
              },
              {
                "id": "patch:npm:debug:20170905:1",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_1_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.5.1 <2.6.9",
                "comments": [],
                "modificationTime": 1575373245873
              },
              {
                "id": "patch:npm:debug:20170905:2",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_2_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.4.0 <2.5.0",
                "comments": [],
                "modificationTime": 1575373245874
              },
              {
                "id": "patch:npm:debug:20170905:3",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/debug/20170905/debug_20170905_0_3_f53962e944a87e6ca9bb622a2a12dffc22a9bb5a.patch"
                ],
                "version": ">=2.0.0 <2.4.0",
                "comments": [],
                "modificationTime": 1575373245875
              }
            ],
            "upgradePath": [
              "express@4.15.5",
              "debug@2.6.9"
            ]
          },
          {
            "id": "npm:base64-url:20180512",
            "url": "https://snyk.io/vuln/npm:base64-url:20180512",
            "title": "Uninitialized Memory Exposure",
            "type": "vuln",
            "description": "## Overview\r\n[base64-url](https://www.npmjs.com/package/base64-url) Base64 encode, decode, escape and unescape for URL applications.\r\n\r\nAffected versions of this package are vulnerable to Uninitialized Memory Exposure. An attacker may extract sensitive data from uninitialized memory or may cause a DoS by passing in a large number, in setups where typed user input can be passed (e.g. from JSON).\r\n\r\n## Details\r\nThe Buffer class on Node.js is a mutable array of binary data, and can be initialized with a string, array or number.\r\n```js\r\nconst buf1 = new Buffer([1,2,3]);\r\n// creates a buffer containing [01, 02, 03]\r\nconst buf2 = new Buffer('test');\r\n// creates a buffer containing ASCII bytes [74, 65, 73, 74]\r\nconst buf3 = new Buffer(10);\r\n// creates a buffer of length 10\r\n```\r\n\r\nThe first two variants simply create a binary representation of the value it received. The last one, however, pre-allocates a buffer of the specified size, making it a useful buffer, especially when reading data from a stream.\r\nWhen using the number constructor of Buffer, it will allocate the memory, but will not fill it with zeros. Instead, the allocated buffer will hold whatever was in memory at the time. If the buffer is not `zeroed` by using `buf.fill(0)`, it may leak sensitive information like keys, source code, and system info.\r\n\r\n\r\n## Remediation\r\nUpgrade `base64-url` to version 2.0.0 or higher.\r\n**Note** This is vulnerable only for Node <=4\r\n\r\n## References\r\n- [HackerOne Report](https://hackerone.com/reports/321692)",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "express-session@1.11.3",
              "uid-safe@2.0.0",
              "base64-url@1.2.1"
            ],
            "package": "base64-url",
            "version": "1.2.1",
            "severity": "high",
            "exploitMaturity": "mature",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<2.0.0"
              ]
            },
            "publicationTime": 1526221586000,
            "disclosureTime": 1526122480000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-201"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-BASE64URL-12144"
              ]
            },
            "credit": [
              "ChALkeR"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N/E:F/RL:O/RC:C",
            "cvssScore": 8.6,
            "patches": [],
            "upgradePath": [
              "express@4.0.0"
            ]
          },
          {
            "id": "SNYK-JS-MORGAN-72579",
            "url": "https://snyk.io/vuln/SNYK-JS-MORGAN-72579",
            "title": "Arbitrary Code Injection",
            "type": "vuln",
            "description": "## Overview\n\n[morgan](https://www.npmjs.com/package/morgan) is a HTTP request logger middleware for node.js.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Injection.\nAn attacker could use the format parameter to inject arbitrary commands.\n\n## Remediation\n\nUpgrade `morgan` to version 1.9.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/expressjs/morgan/commit/e329663836809de4be557b200a5b983ab8b4e6c2)\n\n- [HackerOne Report](https://hackerone.com/reports/390881)\n",
            "from": [
              "express@3.21.2",
              "connect@2.30.2",
              "morgan@1.6.1"
            ],
            "package": "morgan",
            "version": "1.6.1",
            "severity": "medium",
            "exploitMaturity": "proof-of-concept",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<1.9.1"
              ]
            },
            "publicationTime": 1542043775000,
            "disclosureTime": 1541765579000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-5413"
              ],
              "CWE": [
                "CWE-94"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:A/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H/E:P",
            "cvssScore": 6.8,
            "patches": [],
            "upgradePath": [
              "express@4.0.0"
            ]
          }
        ],
        "licenses": []
      },
      "dependencyCount": 95,
      "packageManager": "npm"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "3f019797-e8c7-40fd-8c46-9cc6107ef87e",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 17,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "64e700fd-ea29-451a-bbaf-2826e71e02c4",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:biojava3-core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:biojava3-core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:biojava3-core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_4",
                "source": "api",
                "created": 1580854648451,
                "expires": 1583446627632,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 5,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "f927dd53-ed13-44c3-8d27-c1ef5982f5a9",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:phylo:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:phylo:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:phylo",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:alignment@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:alignment",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 6,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "733a6132-c8f9-4ca2-a4f4-894d3fa3f13b",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 5,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "ce26e647-e557-45df-b1d5-63a5b8ea2b16",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "npm:mime:20170907",
            "url": "https://snyk.io/vuln/npm:mime:20170907",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\n\n[mime](https://www.npmjs.com/package/mime) is a comprehensive, compact MIME type module.\n\n\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS).\nIt uses regex the following regex `/.*[\\.\\/\\\\]/` in its lookup, which can cause a slowdown of 2 seconds for 50k characters.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\n\n## Remediation\n\nUpgrade `mime` to version 1.4.1, 2.0.3 or higher.\n\n\n## References\n\n- [Github Commit 1.x](https://github.com/broofa/node-mime/commit/855d0c4b8b22e4a80b9401a81f2872058eae274d)\n\n- [Github Commit 2.0.x](https://github.com/broofa/node-mime/commit/1df903fdeb9ae7eaa048795b8d580ce2c98f40b0)\n\n- [Github Issue](https://github.com/broofa/node-mime/issues/167)\n\n- [NPM Security Advisory](https://www.npmjs.com/advisories/535)\n",
            "from": [
              "express@4.15.5",
              "serve-static@1.12.6",
              "send@0.15.6",
              "mime@1.3.4"
            ],
            "package": "mime",
            "version": "1.3.4",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<1.4.1",
                ">=2.0.0 <2.0.3"
              ]
            },
            "publicationTime": 1506491320000,
            "disclosureTime": 1504818000000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16138"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MIME-10788"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:mime:20170907:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/mime/20170907/mime_20170907_0_0_855d0c4b8b22e4a80b9401a81f2872058eae274d.patch"
                ],
                "version": "=1.2.11 || =1.3.4",
                "comments": [],
                "modificationTime": 1575373245877
              }
            ],
            "upgradePath": [
              "express@4.16.0",
              "serve-static@1.13.0",
              "send@0.16.0",
              "mime@1.4.1"
            ]
          },
          {
            "id": "npm:mime:20170907",
            "url": "https://snyk.io/vuln/npm:mime:20170907",
            "title": "Regular Expression Denial of Service (ReDoS)",
            "type": "vuln",
            "description": "## Overview\n\n[mime](https://www.npmjs.com/package/mime) is a comprehensive, compact MIME type module.\n\n\nAffected versions of this package are vulnerable to Regular Expression Denial of Service (ReDoS).\nIt uses regex the following regex `/.*[\\.\\/\\\\]/` in its lookup, which can cause a slowdown of 2 seconds for 50k characters.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its original and legitimate users. There are many types of DoS attacks, ranging from trying to clog the network pipes to the system by generating a large volume of traffic from many machines (a Distributed Denial of Service - DDoS - attack) to sending crafted requests that cause a system to crash or take a disproportional amount of time to process.\r\n\r\nThe Regular expression Denial of Service (ReDoS) is a type of Denial of Service attack. Regular expressions are incredibly powerful, but they aren't very intuitive and can ultimately end up making it easy for attackers to take your site down.\r\n\r\nLet’s take the following regular expression as an example:\r\n```js\r\nregex = /A(B|C+)+D/\r\n```\r\n\r\nThis regular expression accomplishes the following:\r\n- `A` The string must start with the letter 'A'\r\n- `(B|C+)+` The string must then follow the letter A with either the letter 'B' or some number of occurrences of the letter 'C' (the `+` matches one or more times). The `+` at the end of this section states that we can look for one or more matches of this section.\r\n- `D` Finally, we ensure this section of the string ends with a 'D'\r\n\r\nThe expression would match inputs such as `ABBD`, `ABCCCCD`, `ABCBCCCD` and `ACCCCCD`\r\n\r\nIt most cases, it doesn't take very long for a regex engine to find a match:\r\n\r\n```bash\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCD\")'\r\n0.04s user 0.01s system 95% cpu 0.052 total\r\n\r\n$ time node -e '/A(B|C+)+D/.test(\"ACCCCCCCCCCCCCCCCCCCCCCCCCCCCX\")'\r\n1.79s user 0.02s system 99% cpu 1.812 total\r\n```\r\n\r\nThe entire process of testing it against a 30 characters long string takes around ~52ms. But when given an invalid string, it takes nearly two seconds to complete the test, over ten times as long as it took to test a valid string. The dramatic difference is due to the way regular expressions get evaluated.\r\n\r\nMost Regex engines will work very similarly (with minor differences). The engine will match the first possible way to accept the current character and proceed to the next one. If it then fails to match the next one, it will backtrack and see if there was another way to digest the previous character. If it goes too far down the rabbit hole only to find out the string doesn’t match in the end, and if many characters have multiple valid regex paths, the number of backtracking steps can become very large, resulting in what is known as _catastrophic backtracking_.\r\n\r\nLet's look at how our expression runs into this problem, using a shorter string: \"ACCCX\". While it seems fairly straightforward, there are still four different ways that the engine could match those three C's:\r\n1. CCC\r\n2. CC+C\r\n3. C+CC\r\n4. C+C+C.\r\n\r\nThe engine has to try each of those combinations to see if any of them potentially match against the expression. When you combine that with the other steps the engine must take, we can use [RegEx 101 debugger](https://regex101.com/debugger) to see the engine has to take a total of 38 steps before it can determine the string doesn't match.\r\n\r\nFrom there, the number of steps the engine must use to validate a string just continues to grow.\r\n\r\n| String | Number of C's | Number of steps |\r\n| -------|-------------:| -----:|\r\n| ACCCX | 3 | 38\r\n| ACCCCX | 4 | 71\r\n| ACCCCCX | 5 | 136\r\n| ACCCCCCCCCCCCCCX | 14 | 65,553\r\n\r\n\r\nBy the time the string includes 14 C's, the engine has to take over 65,000 steps just to see if the string is valid. These extreme situations can cause them to work very slowly (exponentially related to input size, as shown above), allowing an attacker to exploit this and can cause the service to excessively consume CPU, resulting in a Denial of Service.\n\n## Remediation\n\nUpgrade `mime` to version 1.4.1, 2.0.3 or higher.\n\n\n## References\n\n- [Github Commit 1.x](https://github.com/broofa/node-mime/commit/855d0c4b8b22e4a80b9401a81f2872058eae274d)\n\n- [Github Commit 2.0.x](https://github.com/broofa/node-mime/commit/1df903fdeb9ae7eaa048795b8d580ce2c98f40b0)\n\n- [Github Issue](https://github.com/broofa/node-mime/issues/167)\n\n- [NPM Security Advisory](https://www.npmjs.com/advisories/535)\n",
            "from": [
              "express@4.15.5",
              "send@0.15.6",
              "mime@1.3.4"
            ],
            "package": "mime",
            "version": "1.3.4",
            "severity": "low",
            "exploitMaturity": "no-known-exploit",
            "language": "js",
            "packageManager": "npm",
            "semver": {
              "vulnerable": [
                "<1.4.1",
                ">=2.0.0 <2.0.3"
              ]
            },
            "publicationTime": 1506491320000,
            "disclosureTime": 1504818000000,
            "isUpgradable": true,
            "isPatchable": true,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-16138"
              ],
              "CWE": [
                "CWE-400"
              ],
              "ALTERNATIVE": [
                "SNYK-JS-MIME-10788"
              ]
            },
            "credit": [
              "Cristian-Alexandru Staicu"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 3.7,
            "patches": [
              {
                "id": "patch:npm:mime:20170907:0",
                "urls": [
                  "https://snyk-patches.s3.amazonaws.com/npm/mime/20170907/mime_20170907_0_0_855d0c4b8b22e4a80b9401a81f2872058eae274d.patch"
                ],
                "version": "=1.2.11 || =1.3.4",
                "comments": [],
                "modificationTime": 1575373245877
              }
            ],
            "upgradePath": [
              "express@4.16.0",
              "send@0.16.0",
              "mime@1.4.1"
            ]
          }
        ],
        "licenses": []
      },
      "dependencyCount": 47,
      "packageManager": "npm"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "6e1c286e-0dbc-4e62-bbd6-7b7538d9fbde",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:alignment@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:alignment",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-structure@3.0-SNAPSHOT",
              "org.biojava:alignment@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 8,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "9442cd44-0a4e-4fd3-9b2b-7624607047e7",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.google.guava:guava@12.0.1"
            ],
            "package": "com.google.guava:guava",
            "version": "12.0.1",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.google.guava:guava@24.1.1-android"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.aspectj:aspectjrt:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.aspectj:aspectjrt@1.6.10"
            ],
            "package": "org.aspectj:aspectjrt",
            "version": "1.6.10",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@0.9.24",
              "ch.qos.logback:logback-core@0.9.24"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "0.9.24",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 15,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "c42d6c96-5c11-4b81-adee-e16e7039564b",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:sequencing:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:sequencing:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:sequencing",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 4,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "34e9de0c-055e-4907-aab5-c35f73a7be9f",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_2",
                "source": "api",
                "created": 1580855531111,
                "expires": 1588631503006,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "not-vulnerable",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_1",
                "source": "api",
                "created": 1580855496429,
                "expires": 1583447474610,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_3",
                "source": "api",
                "created": 1580855606122,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_1",
                "source": "api",
                "created": 1580855496429,
                "expires": 1583447474610,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_3",
                "source": "api",
                "created": 1580855606122,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_2",
                "source": "api",
                "created": 1580855531111,
                "expires": 1588631503006,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "not-vulnerable",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_2",
                "source": "api",
                "created": 1580855531111,
                "expires": 1588631503006,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "not-vulnerable",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_1",
                "source": "api",
                "created": 1580855496429,
                "expires": 1583447474610,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "isIgnored": true,
            "isPatched": false,
            "upgradePath": [],
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Vul_3",
                "source": "api",
                "created": 1580855606122,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "SNYK-JAVA-ORGYAML-537645",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGYAML-537645",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n`org.yaml:snakeyaml` is a YAML 1.1 parser and emitter for Java.\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nThe Alias feature in SnakeYAML 1.18 allows entity expansion during a load operation, a related issue to CVE-2003-1564.\r\n\r\n*Note* While the Maintainer acknowledges the existence of the issue, they believe it should be solved by sanitizing the `inputStream` to the parser\n\n## Remediation\n\nThere is no fixed version for `org.yaml:snakeyaml`.\n\n\n## References\n\n- [Bitbucket Issue](https://bitbucket.org/asomov/snakeyaml/issues/377/allow-configuration-for-preventing-billion)\n\n- [Maintainer Report](https://bitbucket.org/asomov/snakeyaml/wiki/Billion%20laughs%20attack)\n\n- [Proof Of Concept](https://bitbucket.org/asomov/snakeyaml/commits/04378d05777d21d114a9cdc24976ad49c8919222)\n",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.yaml:snakeyaml@1.7"
            ],
            "package": "org.yaml:snakeyaml",
            "version": "1.7",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,]"
              ]
            },
            "publicationTime": 1576726101000,
            "disclosureTime": 1576121301000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-18640"
              ],
              "CWE": [
                "CWE-189"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:A/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N/E:U/RL:T/RC:U",
            "cvssScore": 4.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-ORGSCALALANG-31592",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGSCALALANG-31592",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\nAffected versions of [`org.scala-lang:scala-compiler`](https://scala-lang.org) are vulnerable to Arbitrary Code Execution.\n\nThe compilation daemon in Scala before 2.10.7, 2.11.x before 2.11.12, and 2.12.x before 2.12.4 uses weak permissions for private files in /tmp/scala-devel/${USER:shared}/scalac-compile-server-port, which allows local users to write to arbitrary class files and consequently gain privileges.\n\n## Remediation\nUpgrade `org.scala-lang:scala-compiler` to version 2.12.4 or higher.\n\n## References\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-15288)\n- [GitHub PR #1](https://github.com/scala/scala/pull/6108)\n- [GitHub PR #2](https://github.com/scala/scala/pull/6120)\n- [GitHub PR #3](https://github.com/scala/scala/pull/6128)\n- [GitHub Commit #1](https://github.com/scala/scala/commit/f3419fc358a8ea6e366538126279da88d4d1fb1f)\n- [GitHub Commit #2](https://github.com/scala/scala/commit/67fcf5ce4496000574676d81ed72e4a6cb9e7757)\n- [GitHub Commit #3](https://github.com/scala/scala/commit/0f624c5e5bdb39967e208c7c16067c3e6c903f1f)\n",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.scalate:scalate-core@1.5.3",
              "org.scala-lang:scala-compiler@2.9.1"
            ],
            "package": "org.scala-lang:scala-compiler",
            "version": "2.9.1",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.10.7),[2.11,2.11.12),[2.12,2.12.4)"
              ]
            },
            "publicationTime": 1511880442036,
            "disclosureTime": 1506978000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15288"
              ],
              "CWE": [
                "CWE-94"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 7.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-ORGSCALALANG-31592",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGSCALALANG-31592",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\nAffected versions of [`org.scala-lang:scala-compiler`](https://scala-lang.org) are vulnerable to Arbitrary Code Execution.\n\nThe compilation daemon in Scala before 2.10.7, 2.11.x before 2.11.12, and 2.12.x before 2.12.4 uses weak permissions for private files in /tmp/scala-devel/${USER:shared}/scalac-compile-server-port, which allows local users to write to arbitrary class files and consequently gain privileges.\n\n## Remediation\nUpgrade `org.scala-lang:scala-compiler` to version 2.12.4 or higher.\n\n## References\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-15288)\n- [GitHub PR #1](https://github.com/scala/scala/pull/6108)\n- [GitHub PR #2](https://github.com/scala/scala/pull/6120)\n- [GitHub PR #3](https://github.com/scala/scala/pull/6128)\n- [GitHub Commit #1](https://github.com/scala/scala/commit/f3419fc358a8ea6e366538126279da88d4d1fb1f)\n- [GitHub Commit #2](https://github.com/scala/scala/commit/67fcf5ce4496000574676d81ed72e4a6cb9e7757)\n- [GitHub Commit #3](https://github.com/scala/scala/commit/0f624c5e5bdb39967e208c7c16067c3e6c903f1f)\n",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.fusesource.scalate:scalate-core@1.5.3",
              "org.scala-lang:scala-compiler@2.9.1"
            ],
            "package": "org.scala-lang:scala-compiler",
            "version": "2.9.1",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.10.7),[2.11,2.11.12),[2.12,2.12.4)"
              ]
            },
            "publicationTime": 1511880442036,
            "disclosureTime": 1506978000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15288"
              ],
              "CWE": [
                "CWE-94"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 7.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "org.scalastuff:scalabeans@0.3",
              "com.google.guava:guava@r09"
            ],
            "package": "com.google.guava:guava",
            "version": "r09",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "org.scalastuff:scalabeans@0.3",
              "com.google.guava:guava@10.0"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGSCALALANG-31592",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGSCALALANG-31592",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\nAffected versions of [`org.scala-lang:scala-compiler`](https://scala-lang.org) are vulnerable to Arbitrary Code Execution.\n\nThe compilation daemon in Scala before 2.10.7, 2.11.x before 2.11.12, and 2.12.x before 2.12.4 uses weak permissions for private files in /tmp/scala-devel/${USER:shared}/scalac-compile-server-port, which allows local users to write to arbitrary class files and consequently gain privileges.\n\n## Remediation\nUpgrade `org.scala-lang:scala-compiler` to version 2.12.4 or higher.\n\n## References\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-15288)\n- [GitHub PR #1](https://github.com/scala/scala/pull/6108)\n- [GitHub PR #2](https://github.com/scala/scala/pull/6120)\n- [GitHub PR #3](https://github.com/scala/scala/pull/6128)\n- [GitHub Commit #1](https://github.com/scala/scala/commit/f3419fc358a8ea6e366538126279da88d4d1fb1f)\n- [GitHub Commit #2](https://github.com/scala/scala/commit/67fcf5ce4496000574676d81ed72e4a6cb9e7757)\n- [GitHub Commit #3](https://github.com/scala/scala/commit/0f624c5e5bdb39967e208c7c16067c3e6c903f1f)\n",
            "from": [
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.scalate:scalate-core@1.5.3",
              "org.scala-lang:scala-compiler@2.9.1"
            ],
            "package": "org.scala-lang:scala-compiler",
            "version": "2.9.1",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.10.7),[2.11,2.11.12),[2.12,2.12.4)"
              ]
            },
            "publicationTime": 1511880442036,
            "disclosureTime": 1506978000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15288"
              ],
              "CWE": [
                "CWE-94"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 7.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "title": "Unsafe Dependancy Resolution",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.module:jackson-module-scala](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-scala) is an Add-on module for Jackson (http://wiki.fasterxml.com/JacksonHome) to support Scala-specific datatypes.\n\n\nAffected versions of this package are vulnerable to Unsafe Dependancy Resolution\ndue to resolving dependencies over an insecure channel (http).\r\n\r\nIf the build occurred over an insecure connection, a malicious user could have perform a Man-in-the-Middle attack during the build and alter the build artifacts that were produced.\r\nIn case that any of these artifacts were compromised, any developers using these could be altered.\r\n \r\n**Note:** In order to validate that this artifact was not compromised, the maintainer would need to confirm that none of the artifacts published to the registry were not altered with. Until this happens, we can not guarantee that this artifact was not compromised even though the probability that this happened is low. \r\n\r\nWe have chosen to alert on this issue when maintainers either decided to issue CVEs themselves, or in cases when maintainers decided against performing audits on there build to verify they had not been compromised.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.module:jackson-module-scala` to version 2.9.9 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-module-scala/pull/406/commits/a2d13cea104ee790759519ade6f2f688791e8198)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-module-scala/issues/400)\n\n- [Jonathan Leitschuh's Blog](https://medium.com/@jonathan.leitschuh/1fc329d898fb)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2"
            ],
            "package": "com.fasterxml.jackson.module:jackson-module-scala",
            "version": "2.1.2",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.9)"
              ]
            },
            "publicationTime": 1560253122000,
            "disclosureTime": 1550838955000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-494",
                "CWE-829"
              ]
            },
            "credit": [
              "JLLeitschuh"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 5.6,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0",
              "com.fasterxml.jackson.core:jackson-core@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.1.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1",
              "com.fasterxml.jackson.core:jackson-core@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0",
              "com.fasterxml.jackson.core:jackson-core@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.1.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1",
              "com.fasterxml.jackson.core:jackson-core@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-core@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.1.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-core@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-core@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.1.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-core@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0",
              "com.fasterxml.jackson.core:jackson-core@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.1.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-core@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.1.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.10.1",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-base@2.10.1",
              "com.fasterxml.jackson.core:jackson-databind@2.10.1"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.fasterxml.jackson.module:jackson-module-scala@2.1.2",
              "com.fasterxml.jackson.core:jackson-databind@2.1.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.1.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:confluence-core@1.2",
              "org.fusesource.wikitext:wikitext-core@1.2"
            ],
            "package": "org.fusesource.wikitext:wikitext-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_3",
                "source": "api",
                "created": 1580855845041,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:textile-core@1.2",
              "org.fusesource.wikitext:wikitext-core@1.2"
            ],
            "package": "org.fusesource.wikitext:wikitext-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_3",
                "source": "api",
                "created": 1580855845041,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:textile-core@1.2",
              "org.fusesource.wikitext:wikitext-core@1.2"
            ],
            "package": "org.fusesource.wikitext:wikitext-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_3",
                "source": "api",
                "created": 1580855845041,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:wikitext-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:confluence-core@1.2",
              "org.fusesource.wikitext:wikitext-core@1.2"
            ],
            "package": "org.fusesource.wikitext:wikitext-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_3",
                "source": "api",
                "created": 1580855845041,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:confluence-core@1.2"
            ],
            "package": "org.fusesource.wikitext:confluence-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_1",
                "source": "api",
                "created": 1580855812197,
                "expires": 1583447796235,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:textile-core@1.2"
            ],
            "package": "org.fusesource.wikitext:textile-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_2",
                "source": "api",
                "created": 1580855822304,
                "expires": 1588631814209,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "not-vulnerable",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:confluence-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:confluence-core@1.2"
            ],
            "package": "org.fusesource.wikitext:confluence-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_1",
                "source": "api",
                "created": 1580855812197,
                "expires": 1583447796235,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.fusesource.wikitext:textile-core:EPL-1.0",
            "title": "EPL-1.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "org.fusesource.scalate:scalate-wikitext@1.5.3",
              "org.fusesource.wikitext:textile-core@1.2"
            ],
            "package": "org.fusesource.wikitext:textile-core",
            "version": "1.2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_Lic_2",
                "source": "api",
                "created": 1580855822304,
                "expires": 1588631814209,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "not-vulnerable",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:rhino:js:MPL-2.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:rhino:js:MPL-2.0",
            "title": "MPL-2.0 license",
            "type": "license",
            "from": [
              "org.fusesource.scalate:scalate-page@1.5.3",
              "rhino:js@1.7R2"
            ],
            "package": "rhino:js",
            "version": "1.7R2",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[1.7R2,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 26,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "208fcb9b-718b-4c85-86be-c1021e68530b",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:sequence-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 8,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "9506f3ec-1258-44c8-a258-911e9545e536",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-core@3.0-SNAPSHOT",
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:biojava3-core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:biojava3-core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:biojava3-core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:biojava3-core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 6,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "ad7d70ff-3575-4ab5-a6fd-7b8fac66645c",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMGOOGLEGUAVA-32236",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.google.guava:guava](https://github.com/google/guava) is a set of core libraries that includes new collection types (such as multimap and multiset,immutable collections, a graph library, functional types, an in-memory cache and more.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nDuring deserialization, two Guava classes accept a caller-specified size parameter and eagerly allocate an array of that size:\r\n* `AtomicDoubleArray` (when serialized with Java serialization)\r\n* `CompoundOrdering` (when serialized with GWT serialization)\r\n\r\nAn attacker may be able to send a specially crafted request which with then cause the server to allocate all it's memory, without validation whether the data size is reasonable.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.google.guava:guava` to version 24.1.1-android, 24.1.1-jre or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/google/guava/commit/7ec8718f1e6e2814dabaa4b9f96b6b33a813101c)\n\n- [Google Group Forum](https://groups.google.com/forum/#!topic/guava-announce/xqWALw4W1vs/discussion)\n\n- [RedHat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1573391)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@r09"
            ],
            "package": "com.google.guava:guava",
            "version": "r09",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[11.0, 24.1.1-android)",
                "(24.1.1-android, 24.1.1-jre)"
              ]
            },
            "publicationTime": 1525268284000,
            "disclosureTime": 1524641295000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-10237"
              ],
              "CWE": [
                "CWE-119"
              ]
            },
            "credit": [
              "Apostolos Giannakidis"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H",
            "cvssScore": 5.9,
            "patches": [],
            "upgradePath": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "org.scalastuff:scalabeans@0.2",
              "com.google.guava:guava@10.0"
            ]
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONMODULE-174825",
            "title": "Unsafe Dependancy Resolution",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.module:jackson-module-scala](https://mvnrepository.com/artifact/com.fasterxml.jackson.module/jackson-module-scala) is an Add-on module for Jackson (http://wiki.fasterxml.com/JacksonHome) to support Scala-specific datatypes.\n\n\nAffected versions of this package are vulnerable to Unsafe Dependancy Resolution\ndue to resolving dependencies over an insecure channel (http).\r\n\r\nIf the build occurred over an insecure connection, a malicious user could have perform a Man-in-the-Middle attack during the build and alter the build artifacts that were produced.\r\nIn case that any of these artifacts were compromised, any developers using these could be altered.\r\n \r\n**Note:** In order to validate that this artifact was not compromised, the maintainer would need to confirm that none of the artifacts published to the registry were not altered with. Until this happens, we can not guarantee that this artifact was not compromised even though the probability that this happened is low. \r\n\r\nWe have chosen to alert on this issue when maintainers either decided to issue CVEs themselves, or in cases when maintainers decided against performing audits on there build to verify they had not been compromised.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.module:jackson-module-scala` to version 2.9.9 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-module-scala/pull/406/commits/a2d13cea104ee790759519ade6f2f688791e8198)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-module-scala/issues/400)\n\n- [Jonathan Leitschuh's Blog](https://medium.com/@jonathan.leitschuh/1fc329d898fb)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0"
            ],
            "package": "com.fasterxml.jackson.module:jackson-module-scala",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.9)"
              ]
            },
            "publicationTime": 1560253122000,
            "disclosureTime": 1550838955000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-494",
                "CWE-829"
              ]
            },
            "credit": [
              "JLLeitschuh"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L",
            "cvssScore": 5.6,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31519",
            "title": "Denial of Service (DoS)",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-core](https://github.com/FasterXML/jackson-core) is a Core Jackson abstractions, basic JSON streaming API implementation\n\n\nAffected versions of this package are vulnerable to Denial of Service (DoS).\nIf the REST endpoint consumes POST requests with JSON or XML data and data are invalid, the first unrecognized token is printed to server.log\r\n> If the first token is word of length 10MB, the whole word is printed. This is potentially dangerous and can be used to attack the server by filling the disk with logs.\n\n## Details\nDenial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users.\r\n\r\nUnlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime.\r\n\r\nOne popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines.\r\n\r\nWhen it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries.\r\n\r\nTwo common types of DoS vulnerabilities:\r\n\r\n* High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, [commons-fileupload:commons-fileupload](SNYK-JAVA-COMMONSFILEUPLOAD-30082).\r\n\r\n* Crash - An attacker sending crafted requests that could cause the system to crash. For Example,  [npm `ws` package](npm:ws:20171108)\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-core` to version 2.8.6 or higher.\n\n\n## References\n\n- [Github PR](https://github.com/FasterXML/jackson-core/pull/322)\n\n- [Jira Issue](https://issues.jboss.org/browse/JBEAP-6316)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-core@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-core",
            "version": "2.0.0",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.6)"
              ]
            },
            "publicationTime": 1505921315000,
            "disclosureTime": 1484179200000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-399"
              ]
            },
            "credit": [
              "Alessio Soldano"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.module:jackson-module-jaxb-annotations@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.module:jackson-module-scala@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72884",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19361`) is not identical to `CVE-2018-19362` and `CVE-2018-19360`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456723000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19361"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72883",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `axis2-transport-jms ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19360`) is not identical to `CVE-2018-19362` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19360"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72882",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks due to not blocking the `jboss-common-core ` class from polymorphic deserialization.\r\n\r\n**Note** This vulnerability (`CVE-2018-19362`) is not identical to `CVE-2018-19360` and `CVE-2018-19361`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.8, 2.8.11.3, 2.7.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/42912cac4753f3f718ece875e4d486f8264c2f2b)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2186)\n\n- [GitHub Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.8)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.8)",
                "[2.8.0,2.8.11.3)",
                "[2.0.0, 2.7.9.5)"
              ]
            },
            "publicationTime": 1546534911000,
            "disclosureTime": 1546456724000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-19362"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Wuguixiong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72451",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA malicious user could perform a SSRF attack via the `axis2-jaxws` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14721`) is not identical to `CVE-2018-12018`, `CVE-2018-14719`, `CVE-2018-14720`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278679000,
            "disclosureTime": 1532712286000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14721"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72450",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack via the `blaze-ds-opt` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14719`) is not identical to `CVE-2018-12018`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n\n- [GitHub Release Notes](https://github.com/FasterXML/jackson-databind/blob/a066415d66a6b1a4688ff0ed25695aa3a86ac130/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278558000,
            "disclosureTime": 1532712165000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14719"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72449",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform an XML External Entity (XXE) Injection via the `JDK` classes due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14720`) is not identical to `CVE-2018-12018`, `CVE-2018-14729`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278357000,
            "disclosureTime": 1532712017000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14720"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72448",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n \n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attacks via the ` slf4j-ext` gadget due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-14718`) is not identical to `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722`,`CVE-2018-12023` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade com.fasterxml.jackson.core:jackson-databind to version 2.6.7.2, 2.7.9.5, 2.8.11.3, 2.9.7 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/87d29af25e82a249ea15858e2d4ecbf64091db44)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2097)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.2)",
                "[2.7.9, 2.7.9.5)",
                "[2.8.0 ,2.8.11.3)",
                "[2.9.0, 2.9.7)"
              ]
            },
            "publicationTime": 1539278381000,
            "disclosureTime": 1532711989000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-14718"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72447",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12023`) is not identical to `CVE-2018-12018`, `CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/28badf7ef60ac3e7ef151cd8e8ec010b8479226a)\n\n- [GitHub PR](https://github.com/FasterXML/jackson-databind/issues/2058)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0-RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539278149000,
            "disclosureTime": 1527614150000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12023"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72446",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt may allow content exfiltration (remote access by sending contents over ftp) when untrusted content is deserialized with default typing enabled. This vulnerability is due to an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-11307`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14722` and `CVE-2018-14723`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/27b4defc270454dea6842bd9279f17387eceb737)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2032)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0.RC1, 2.7.9.4)",
                "[2.8.0.rc1, 2.8.11.2)",
                "[2.9.0, 2.9.6)"
              ]
            },
            "publicationTime": 1539277850000,
            "disclosureTime": 1525972258000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-11307"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-72445",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker could perform a Remote Code Execution attack, if the user is handling untrusted content or using the `Default Typing` feature.  an incomplete fix for the [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) deserialization flaw.\r\n\r\n**Note:** This vulnerability (`CVE-2018-12022`) is not identical to `CVE-2018-12018`,`CVE-2018-12019`, `CVE-2018-14720`, `CVE-2018-14721`, `CVE-2018-14723` and `CVE-2018-11307`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.7.9.4, 2.8.11.2, 2.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/7487cf7eb14be2f65a1eb108e8629c07ef45e0a1)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2052)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.7.9.4)",
                "[2.8.0,2.8.11.2)",
                "[2.9.0,2.9.6)"
              ]
            },
            "publicationTime": 1539277203000,
            "disclosureTime": 1527613204000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-12022"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            "cvssScore": 10.0,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-540500",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nTwo additional `net.sf.ehcache` gadgets are not blacklisted.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.2 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/fc4214a883dc087070f25da738ef0d49c2f3387e)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2526)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.2)"
              ]
            },
            "publicationTime": 1578028448000,
            "disclosureTime": 1578028448000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-20330"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "UltramanGaia"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-472980",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Blog Post](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/b5a304a98590b6bb766134f9261e6566dcbbb6d0)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2498)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.0.0, 2.9.10.1)"
              ]
            },
            "publicationTime": 1570952515000,
            "disclosureTime": 1570917130000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17531"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Zhangxianhui"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469676",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.p6spy.engine.spy.P6DataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16943"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-471943",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered related to `net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/191a4cdf87b56d2ddddb77edd895ee756b7f75eb)\n\n- [GitHub Comparison](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.3...jackson-databind-2.9.10)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2460)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1570410866000,
            "disclosureTime": 1570410866000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-17267"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-469674",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered within `org.apache.commons.dbcp.datasources.SharedPoolDataSource` was not blocked. An attacker could leverage this gadget type  to perform Remote Code Execution attacks through deserialization.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.10.1 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/9593e16cf5a3d289a9c584f7123639655de9ddac)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2478)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.9.10.1)"
              ]
            },
            "publicationTime": 1570038213000,
            "disclosureTime": 1569951813000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16942"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "bsmali4"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467016",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nNone\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2420)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568644657000,
            "disclosureTime": 1568644658000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Tatu Saloranta"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467015",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariConfig` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-16335.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr2, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/d4983c740fec7d5576b207a8c30a63d3ea7443de)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2410)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr2)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676445000,
            "disclosureTime": 1568590045000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14540"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "iSafeBlue"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-467014",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered as `com.zaxxer.hikari.HikariDataSource` was not blocked.\r\n**Note:** This is a different vulnerability than CVE-2019-14540.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.10.0.pr3, 2.9.10 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2449)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.10.0.pr1,2.10.0.pr3)",
                "[,2.9.10)"
              ]
            },
            "publicationTime": 1568676624000,
            "disclosureTime": 1568590224000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-16335"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-455617",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\n`SubTypeValidator.java` mishandles default typing when `ehcache` is used, leading to remote code execution.\n\n## Description\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.2, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Diff](https://github.com/FasterXML/jackson-databind/compare/jackson-databind-2.9.9.1...jackson-databind-2.9.9.2)\n\n- [GitHub Issue 2 - CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2395)\n\n- [GitHub Issue CVE-2019-14379](https://github.com/FasterXML/jackson-databind/issues/2387)\n\n- [GitHub Issue CVE-2019-14439](https://github.com/FasterXML/jackson-databind/issues/2389)\n\n- [Snyk Blog](https://snyk.io/blog/jackson-deserialization-vulnerability/)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.2)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1564404042000,
            "disclosureTime": 1564404042000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-14379",
                "CVE-2019-14439"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450917",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nwhich allows attackers to have a variety of impacts by leveraging failure to block the `logback-core` class from polymorphic deserialization. Depending on the `classpath` content, remote code execution may be possible.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [Debian Lists](https://lists.debian.org/debian-lts-announce/2019/06/msg00019.html)\n\n- [Github Fix](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/2334)\n\n- [Jackson CVEs Don't Panic - Blog](https://medium.com/@cowtowncoder/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062)\n\n- [Release Notes](https://github.com/FasterXML/jackson-databind/blob/a6667bcd1f0114f5b004d5203f4139b1e6104a1c/release-notes/VERSION-2.x)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1561458389000,
            "disclosureTime": 1559039279000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12384"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "College of software Nankai University"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-450207",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nA Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.x through 2.9.9. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has JDOM 1.x or 2.x jar in the classpath, an attacker can send a specifically crafted JSON message that allows them to read arbitrary local files on the server.\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9.1, 2.8.11.4, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/5f7c69bba07a7155adde130d9dee2e54a54f1fa5)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2341)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9.1)",
                "[2.8.0,2.8.11.4)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1560954856000,
            "disclosureTime": 1560954856000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12814"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32111",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nIt allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 deserialization flaw. This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the `c3p0` libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11.1, 2.9.5 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/6799f8f10cc78e9af6d443ed6982d00a13f2e7d2)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1931)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11.1)",
                "[2.9.0, 2.9.5)"
              ]
            },
            "publicationTime": 1519658020000,
            "disclosureTime": 1518275620000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-7489"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32044",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507) and [CVE-2017-17485](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043)). This is exploitable via two different gadgets that bypass a blacklist.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/GulajavaMinistudio/jackson-databind/pull/92/commits/038b471e2efde2e8f96b4e0be958d3e5a1ff1d05)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1899)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516713444000,
            "disclosureTime": 1516290018000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2018-5968"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Rui Chong"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 8.1,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nAn attacker may exploit this issue by sending a maliciously crafted input to the `readValue` method of the `ObjectMapper`.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.9 or higher.\n\n\n## References\n\n- [Github Commit](https://github.com/FasterXML/jackson-databind/commit/60d459cedcf079c6106ae7da2ac562bc32dcabe1)\n\n- [Github Issue](https://github.com/FasterXML/jackson-databind/issues/1599)\n\n- [Github PR](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1462702)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.9)"
              ]
            },
            "publicationTime": 1505400228000,
            "disclosureTime": 1491858000000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7525"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-32043",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)). This is exploitable by sending maliciously crafted JSON input to the readValue method of the ObjectMapper, bypassing a blacklist that is ineffective if the Spring libraries are available in the classpath.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.8.11, 2.9.4 or higher.\n\n\n## References\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/1855)\n\n- [PoC Project](https://github.com/irsl/jackson-rce-via-spel/)\n\n- [Possible GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/2235894210c75f624a3d0cd60bfb0434a20a18bf)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.8.11)",
                "[2.9.0,2.9.4)"
              ]
            },
            "publicationTime": 1516624255000,
            "disclosureTime": 1515584488000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-17485"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Imre Rad"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31573",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\ndue to an incomplete black list (incomplete fix for [CVE-2017-7525](https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-31507)).\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.6.7.1, 2.7.9.1, 2.8.10 or higher.\n\n\n## References\n\n- [Github Commit #1](https://github.com/FasterXML/jackson-databind/commit/e8f043d1)\n\n- [Github Issue #1](https://github.com/FasterXML/jackson-databind/issues/1680)\n\n- [Github Issue #2](https://github.com/FasterXML/jackson-databind/issues/1737)\n\n- [Redhat Bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id&#x3D;1506612)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,2.6.7.1)",
                "[2.7.0,2.7.9.1)",
                "[2.8.0,2.8.10)"
              ]
            },
            "publicationTime": 1510197212000,
            "disclosureTime": 1498510800000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-15095"
              ],
              "CWE": [
                "CWE-184"
              ]
            },
            "credit": [
              "Liao Xinxi"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          },
          {
            "id": "SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "url": "https://snyk.io/vuln/SNYK-JAVA-COMFASTERXMLJACKSONCORE-174736",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[com.fasterxml.jackson.core:jackson-databind](https://github.com/FasterXML/jackson-databind) is a library which contains the general-purpose data-binding functionality and tree-model for Jackson Data Processor.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data.\nWhen Default Typing is enabled for an externally exposed JSON endpoint, the service has the mysql-connector-java jar in the classpath. An attacker can host a crafted MySQL server reachable by the victim and send a crafted JSON message that allows them to read arbitrary local files on the server. This occurs due to missing `com.mysql.cj.jdbc.admin.MiniAdmin` validation.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `com.fasterxml.jackson.core:jackson-databind` to version 2.9.9, 2.8.11.3, 2.7.9.6 or higher.\n\n\n## References\n\n- [GitHub Commit](https://github.com/FasterXML/jackson-databind/commit/dda513bd7251b4f32b7b60b1c13740e3b5a43024)\n\n- [GitHub Issue](https://github.com/FasterXML/jackson-databind/issues/2326)\n\n- [Github Release Tag](https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9.9)\n",
            "from": [
              "com.wordnik:swagger-core_2.9.1@1.1.0",
              "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider@2.0.0",
              "com.fasterxml.jackson.core:jackson-databind@2.0.0"
            ],
            "package": "com.fasterxml.jackson.core:jackson-databind",
            "version": "2.0.0",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[2.9.0,2.9.9)",
                "[2.8.0,2.8.11.3)",
                "[,2.7.9.6)"
              ]
            },
            "publicationTime": 1558116778000,
            "disclosureTime": 1558116778000,
            "isUpgradable": false,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-12086"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": []
          }
        ],
        "licenses": []
      },
      "dependencyCount": 18,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "ca98b7a3-e4b7-4fdf-a4c6-17f15501679a",
      "ok": true,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_2",
                "source": "api",
                "created": 1580853669176,
                "expires": 1588629660435,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "not-vulnerable",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_3",
                "source": "api",
                "created": 1580853653681,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "wont-fix",
                "disregardIfFixable": false
              }
            ]
          },
          {
            "id": "snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:alignment:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [],
            "package": "org.biojava:alignment",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            },
            "isIgnored": true,
            "isPatched": false,
            "ignored": [
              {
                "path": [
                  "*"
                ],
                "reason": "VA_Ignore_1",
                "source": "api",
                "created": 1580852640615,
                "expires": 1583444604683,
                "ignoredBy": {
                  "id": "eac56b5c-589a-41ca-bd2e-ba2711a926c0",
                  "name": "App Account App Admin",
                  "email": "testadmin1@levelops.io"
                },
                "reasonType": "temporary-ignore",
                "disregardIfFixable": false
              }
            ]
          }
        ]
      },
      "dependencyCount": 4,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "57a0b811-ec56-427d-8dbc-5a8ed44dbc46",
      "ok": false,
      "issues": {
        "vulnerabilities": [],
        "licenses": [
          {
            "id": "snyk:lic:maven:org.biojava:core:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:core:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:core",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "url": "https://snyk.io/vuln/snyk:lic:maven:org.biojava:bytecode:GPL-3.0",
            "title": "GPL-3.0 license",
            "type": "license",
            "from": [
              "org.biojava:core@3.0-SNAPSHOT",
              "org.biojava:bytecode@3.0-SNAPSHOT"
            ],
            "package": "org.biojava:bytecode",
            "version": "3.0-SNAPSHOT",
            "severity": "high",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 4,
      "packageManager": "maven"
    },
    {
      "org_id": "c85e8605-0a73-443e-a3f0-f21a871761b1",
      "project_id": "592f8822-937c-4d76-a605-a122c366c7b6",
      "ok": false,
      "issues": {
        "vulnerabilities": [
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32383",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32383",
            "title": "Cache Poisoning",
            "type": "vuln",
            "description": "## Overview\n\n[org.eclipse.jetty:jetty-http](https://github.com/eclipse/jetty.project) is a is a http module for jetty server.\n\n\nAffected versions of this package are vulnerable to Cache Poisoning.\nAn `HTTP/1` style request line (i.e. method space URI space version) that declares a version of `HTTP/0.9` was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version, the response sent could be interpreted by the intermediary as `HTTP/1` headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response.\n\n## Remediation\n\nUpgrade `org.eclipse.jetty:jetty-http` to version 9.3.24.v20180605, 9.4.11.v20180605 or higher.\n\n\n## References\n\n- [Eclipse Bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=535667)\n\n- [GitHub Commit](https://github.com/eclipse/jetty.project/commit/a285deea42fcab60d9edcf994e458c238a348b55)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-7656)\n",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-http@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-http",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.3.24.v20180605)",
                "[9.4.0.M0,9.4.11.v20180605)"
              ]
            },
            "publicationTime": 1530197950000,
            "disclosureTime": 1528374680000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7656"
              ],
              "CWE": [
                "CWE-444"
              ]
            },
            "credit": [
              "Regis Leroy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-servlet@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-security@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-server@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-http@9.3.24.v20180605"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "title": "Timing Attack",
            "type": "vuln",
            "description": "## Overview\r\n[org.eclipse.jetty:jetty-util](https://github.com/eclipse/jetty.project)  is a lightweight highly scalable java based web server and servlet engine.\r\n\r\nAffected versions of this package are vulnerable to Timing Attacks. A flaw in the `util/security/Password.java` class makes it easier for remote attackers to obtain access by observing elapsed times before rejection of incorrect passwords.\r\n\r\n## Remediation\r\nUpgrade `org.eclipse.jetty:jetty-util` to versions 9.2.22, 9.3.20, 9.4.6 or higher.\r\n\r\n## References\r\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-9735)\r\n- [GitHub Issue](https://github.com/eclipse/jetty.project/issues/1556)",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-http@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-io@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-util@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-util",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.2.22.v20170606)",
                "[9.3.0.M0, 9.3.20.v20170531)",
                "[9.4.0.M0, 9.4.6.v20170531)"
              ]
            },
            "publicationTime": 1522742847000,
            "disclosureTime": 1497648540000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-9735"
              ],
              "CWE": [
                "CWE-200"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-servlet@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-security@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-server@9.0.0.v20130308",
              "org.eclipse.jetty:jetty-http@9.0.0.v20130308"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32385",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32385",
            "title": "Authorization Bypass",
            "type": "vuln",
            "description": "## Overview\r\n[org.eclipse.jetty:jetty-server](https://github.com/eclipse/jetty.project) is a lightweight highly scalable java based web server and servlet engine.\r\n\r\nAffected versions of this package are vulnerable to Authorization Bypass. When it presented with two content-lengths headers, Jetty ignored the second. When presented with a content-length and a chunked encoding header, the content-length was ignored (as per RFC 2616). If an intermediary decided on the shorter length, but still passed on the longer body, then body content could be interpreted by Jetty as a pipelined request. If the intermediary was imposing authorization, the fake pipelined request would bypass that authorization.\r\n\r\n## Remediation\r\nUpgrade `org.eclipse.jetty:jetty-server` to versions  9.2.25, 9.3.24, 9.4.11 or higher.\r\n\r\n## References\r\n- [Eclipse Bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=535669)\r\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-7658)",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-server",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.2.25.v20180606)",
                "[9.3.0.M0, 9.3.24.v20180605)",
                "[9.4.0.M0, 9.4.11.v20180605)"
              ]
            },
            "publicationTime": 1530197950000,
            "disclosureTime": 1528288280000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7658"
              ],
              "CWE": [
                "CWE-444"
              ]
            },
            "credit": [
              "Regis Leroy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.2.25.v20180606",
              "org.eclipse.jetty:jetty-servlet@9.2.25.v20180606",
              "org.eclipse.jetty:jetty-security@9.2.25.v20180606",
              "org.eclipse.jetty:jetty-server@9.2.25.v20180606"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-32151",
            "title": "Timing Attack",
            "type": "vuln",
            "description": "## Overview\r\n[org.eclipse.jetty:jetty-util](https://github.com/eclipse/jetty.project)  is a lightweight highly scalable java based web server and servlet engine.\r\n\r\nAffected versions of this package are vulnerable to Timing Attacks. A flaw in the `util/security/Password.java` class makes it easier for remote attackers to obtain access by observing elapsed times before rejection of incorrect passwords.\r\n\r\n## Remediation\r\nUpgrade `org.eclipse.jetty:jetty-util` to versions 9.2.22, 9.3.20, 9.4.6 or higher.\r\n\r\n## References\r\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-9735)\r\n- [GitHub Issue](https://github.com/eclipse/jetty.project/issues/1556)",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-xml@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-util@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-util",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.2.22.v20170606)",
                "[9.3.0.M0, 9.3.20.v20170531)",
                "[9.4.0.M0, 9.4.6.v20170531)"
              ]
            },
            "publicationTime": 1522742847000,
            "disclosureTime": 1497648540000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-9735"
              ],
              "CWE": [
                "CWE-200"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.2.22.v20170606",
              "org.eclipse.jetty:jetty-xml@9.2.22.v20170606",
              "org.eclipse.jetty:jetty-util@9.2.22.v20170606"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-460763",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-460763",
            "title": "Cache Poisoning",
            "type": "vuln",
            "description": "## Overview\n\n[org.eclipse.jetty:jetty-server](https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-server) is a lightweight highly scalable java based web server and servlet engine.\n\n\nAffected versions of this package are vulnerable to Cache Poisoning.\nAn `HTTP/1` style request line (i.e. method space URI space version) that declares a version of `HTTP/0.9` was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version, the response sent could be interpreted by the intermediary as `HTTP/1` headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response.\n\n## Remediation\n\nUpgrade `org.eclipse.jetty:jetty-server` to version 9.3.24.v20180605, 9.4.11.v20180605 or higher.\n\n\n## References\n\n- [Eclipse Bug](https://bugs.eclipse.org/bugs/show_bug.cgi?id=535667)\n\n- [GitHub Commit](https://github.com/eclipse/jetty.project/commit/a285deea42fcab60d9edcf994e458c238a348b55)\n\n- [NVD](https://nvd.nist.gov/vuln/detail/CVE-2017-7656)\n",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-server",
            "version": "8.1.5.v20120716",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[,9.3.24.v20180605)",
                "[9.4.0.M0,9.4.11.v20180605)"
              ]
            },
            "publicationTime": 1530197950000,
            "disclosureTime": 1528374680000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-7656"
              ],
              "CWE": [
                "CWE-444"
              ]
            },
            "credit": [
              "Regis Leroy"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
            "cvssScore": 7.5,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-servlet@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-security@9.3.24.v20180605",
              "org.eclipse.jetty:jetty-server@9.3.24.v20180605"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-31407",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-31407",
            "title": "Deserialization of Untrusted Data",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-classic](https://mvnrepository.com/artifact/ch.qos.logback/logback-classic) is a reliable, generic, fast and flexible logging library for Java.\n\n\nAffected versions of this package are vulnerable to Deserialization of Untrusted Data\nvia the the `SocketServer` and `ServerSocketReceiver` components.\r\n\r\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-classic` to version 1.2.0 or higher.\n\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## References\n\n- [GitHub Commit](https://github.com/qos-ch/logback/commit/979b042cb1f0b4c1e5869ccc8912e68c39f769f9)\n\n- [Logback Security Advisory](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929)\n",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "1.0.6",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.3,1.2.0)"
              ]
            },
            "publicationTime": 1495353156000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.2.0"
            ]
          },
          {
            "id": "SNYK-JAVA-CHQOSLOGBACK-30208",
            "url": "https://snyk.io/vuln/SNYK-JAVA-CHQOSLOGBACK-30208",
            "title": "Arbitrary Code Execution",
            "type": "vuln",
            "description": "## Overview\n\n[ch.qos.logback:logback-core](https://mvnrepository.com/artifact/ch.qos.logback/logback-core) is a logback-core module.\n\n\nAffected versions of this package are vulnerable to Arbitrary Code Execution.\nA configuration can be turned on to allow remote logging through interfaces that accept untrusted serialized data. Authenticated attackers on the adjacent network can exploit this vulnerability to run arbitrary code through the deserialization of custom gadget chains.\n\n## Details\nSerialization is a process of converting an object into a sequence of bytes which can be persisted to a disk or database or can be sent through streams. The reverse process of creating object from sequence of bytes is called deserialization. Serialization is commonly used for communication (sharing objects between multiple hosts) and persistence (store the object state in a file or a database). It is an integral part of popular protocols like _Remote Method Invocation (RMI)_, _Java Management Extension (JMX)_, _Java Messaging System (JMS)_, _Action Message Format (AMF)_, _Java Server Faces (JSF) ViewState_, etc.\r\n\r\n  \r\n\r\n_Deserialization of untrusted data_ ([CWE-502](https://cwe.mitre.org/data/definitions/502.html)), is when the application deserializes untrusted data without sufficiently verifying that the resulting data will be valid, letting the attacker to control the state or the flow of the execution.\r\n\r\n  \r\n\r\nJava deserialization issues have been known for years. However, interest in the issue intensified greatly in 2015, when classes that could be abused to achieve remote code execution were found in a [popular library (Apache Commons Collection)](https://snyk.io/vuln/SNYK-JAVA-COMMONSCOLLECTIONS-30078). These classes were used in zero-days affecting IBM WebSphere, Oracle WebLogic and many other products.\r\n\r\n  \r\n\r\nAn attacker just needs to identify a piece of software that has both a vulnerable class on its path, and performs deserialization on untrusted data. Then all they need to do is send the payload into the deserializer, getting the command executed.\r\n\r\n  \r\n\r\n> Developers put too much trust in Java Object Serialization. Some even de-serialize objects pre-authentication. When deserializing an Object in Java you typically cast it to an expected type, and therefore Java's strict type system will ensure you only get valid object trees. Unfortunately, by the time the type checking happens, platform code has already created and executed significant logic. So, before the final type is checked a lot of code is executed from the readObject() methods of various objects, all of which is out of the developer's control. By combining the readObject() methods of various classes which are available on the classpath of the vulnerable application an attacker can execute functions (including calling Runtime.exec() to execute local OS commands).\r\n\r\n- Apache Blog\r\n\r\n  \r\n\r\nThe vulnerability, also know as _Mad Gadget_\r\n\r\n> Mad Gadget is one of the most pernicious vulnerabilities we’ve seen. By merely existing on the Java classpath, seven “gadget” classes in Apache Commons Collections (versions 3.0, 3.1, 3.2, 3.2.1, and 4.0) make object deserialization for the entire JVM process Turing complete with an exec function. Since many business applications use object deserialization to send messages across the network, it would be like hiring a bank teller who was trained to hand over all the money in the vault if asked to do so politely, and then entrusting that teller with the key. The only thing that would keep a bank safe in such a circumstance is that most people wouldn’t consider asking such a question.\r\n\r\n- Google\n\n## Remediation\n\nUpgrade `ch.qos.logback:logback-core` to version 1.1.11 or higher.\n\n\n## References\n\n- [Logback News](https://logback.qos.ch/news.html)\n\n- [NVD](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2017-5929/)\n",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6",
              "ch.qos.logback:logback-core@1.0.6"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "1.0.6",
            "severity": "high",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[, 1.1.11)"
              ]
            },
            "publicationTime": 1490110244000,
            "disclosureTime": 1489388340000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2017-5929"
              ],
              "CWE": [
                "CWE-502"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            "cvssScore": 9.8,
            "patches": [],
            "upgradePath": [
              "ch.qos.logback:logback-classic@1.1.11",
              "ch.qos.logback:logback-core@1.1.11"
            ]
          },
          {
            "id": "SNYK-JAVA-ORGECLIPSEJETTY-174560",
            "url": "https://snyk.io/vuln/SNYK-JAVA-ORGECLIPSEJETTY-174560",
            "title": "Information Exposure",
            "type": "vuln",
            "description": "## Overview\n\n[org.eclipse.jetty:jetty-server](https://mvnrepository.com/artifact/org.eclipse.jetty/jetty-server) is a lightweight highly scalable java based web server and servlet engine.\n\n\nAffected versions of this package are vulnerable to Information Exposure.\nThe configuration of a Jetty server may be leaked as part of a HTTP 404 response. This is due to the `DefaultHandler` class producing an error page during an exception.\n\n## Remediation\n\nUpgrade `org.eclipse.jetty:jetty-server` to version 9.2.28.v20190418, 9.3.27.v20190418, 9.4.17.v20190418 or higher.\n\n\n## References\n\n- [Eclipse Report](https://bugs.eclipse.org/bugs/show_bug.cgi?id=546577)\n\n- [GitHub Commit](https://github.com/eclipse/jetty.project/commit/04c994712c0b29824633598cfe0bf709f3b96f09)\n\n- [GitHub Issue](https://github.com/eclipse/jetty.project/issues/3555)\n",
            "from": [
              "org.eclipse.jetty:jetty-webapp@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-servlet@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-security@8.1.5.v20120716",
              "org.eclipse.jetty:jetty-server@8.1.5.v20120716"
            ],
            "package": "org.eclipse.jetty:jetty-server",
            "version": "8.1.5.v20120716",
            "severity": "medium",
            "exploitMaturity": "no-known-exploit",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[7.0.0.M0,9.2.28.v20190418)",
                "[9.3.0.M0,9.3.27.v20190418)",
                "[9.4.0.M0,9.4.17.v20190418)"
              ]
            },
            "publicationTime": 1555967337000,
            "disclosureTime": 1555967337000,
            "isUpgradable": true,
            "isPatchable": false,
            "isPinnable": false,
            "identifiers": {
              "CVE": [
                "CVE-2019-10247"
              ],
              "CWE": [
                "CWE-213"
              ]
            },
            "credit": [
              "Unknown"
            ],
            "CVSSv3": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N",
            "cvssScore": 5.3,
            "patches": [],
            "upgradePath": [
              "org.eclipse.jetty:jetty-webapp@9.2.28.v20190418",
              "org.eclipse.jetty:jetty-servlet@9.2.28.v20190418",
              "org.eclipse.jetty:jetty-security@9.2.28.v20190418",
              "org.eclipse.jetty:jetty-server@9.2.28.v20190418"
            ]
          }
        ],
        "licenses": [
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-classic:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6"
            ],
            "package": "ch.qos.logback:logback-classic",
            "version": "1.0.6",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          },
          {
            "id": "snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "url": "https://snyk.io/vuln/snyk:lic:maven:ch.qos.logback:logback-core:(EPL-1.0_OR_LGPL-2.0)",
            "title": "Dual license: EPL-1.0, LGPL-2.0",
            "type": "license",
            "from": [
              "ch.qos.logback:logback-classic@1.0.6",
              "ch.qos.logback:logback-core@1.0.6"
            ],
            "package": "ch.qos.logback:logback-core",
            "version": "1.0.6",
            "severity": "medium",
            "language": "java",
            "packageManager": "maven",
            "semver": {
              "vulnerable": [
                "[0.9.18,)"
              ]
            }
          }
        ]
      },
      "dependencyCount": 20,
      "packageManager": "sbt"
    }
  ]