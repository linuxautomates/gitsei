package io.levelops.commons.databases.services;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.MoreObjects;
import io.levelops.commons.databases.converters.DbPluginResultConverters;
import io.levelops.commons.databases.models.database.SortingOrder;
import io.levelops.commons.databases.models.database.mappings.ComponentProductMapping;
import io.levelops.commons.databases.models.database.plugins.DbPluginResult;
import io.levelops.commons.databases.models.database.plugins.DbPluginResultLabel;
import io.levelops.commons.databases.utils.SqlInsertQuery;
import io.levelops.commons.databases.utils.TransactionCallback;
import io.levelops.commons.dates.DateUtils;
import io.levelops.commons.models.DbListResponse;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.logging.log4j.util.Strings;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Service;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import javax.sql.DataSource;

@Log4j2
@Service
public class PluginResultsDatabaseService extends DatabaseService<DbPluginResult> {

    public static final String RESULTS_TABLE = "plugin_results";
    private static final String LABELS_TABLE = "plugin_result_labels";
    private static final String MAPPINGS_TABLE = "component_product_mappings";
    private static final String PLUGINS_TABLE = "plugins";
    private static final String LABEL_ITEM_SEPATATOR = ":,:";
    private static final String LABEL_KEY_VALUE_SEPATATOR = ":k_v:";
    private final ObjectMapper mapper;
    protected final NamedParameterJdbcTemplate template;

    private final ComponentProductMappingService mappingService;

    @Autowired
    public PluginResultsDatabaseService(DataSource dataSource, ObjectMapper mapper, final ComponentProductMappingService mappingService) {
        super(dataSource);
        this.mapper = mapper;
        template = new NamedParameterJdbcTemplate(dataSource);
        this.mappingService = mappingService;
    }

    @Override
    public Set<Class<? extends DatabaseService<?>>> getReferences() {
        return Set.of(ComponentProductMappingService.class);
    }

    /**
     * NOTE: this does not return id unless insert was successful.
     */
    @Override
    public String insert(String company, DbPluginResult pluginResult) throws SQLException {
        String resultId = MoreObjects.firstNonNull(pluginResult.getId(), UUID.randomUUID().toString());

        SqlInsertQuery insertQuery = SqlInsertQuery.builder(mapper)
                .schema(company)
                .table(RESULTS_TABLE)
                .castField("id", resultId, "uuid")
                .field("plugin_id", pluginResult.getPluginId())
                .field("version", pluginResult.getVersion())
                .field("successful", pluginResult.getSuccessful())
                .jsonField("metadata", pluginResult.getMetadata())
                .field("gcs_path", pluginResult.getGcsPath())
                .returnAutoGeneratedKeys(true)
                .build();

        var finalId = template.getJdbcTemplate().execute(TransactionCallback.of(conn -> {
            PreparedStatement insertResultStmt = insertQuery.prepareStatement(conn);
            int affectedRows = insertResultStmt.executeUpdate();
            if (affectedRows <= 0) {
                return null;
            }
            if (CollectionUtils.isEmpty(pluginResult.getLabels())) {
                return resultId;
            }
            for (DbPluginResultLabel label : pluginResult.getLabels()) {
                SqlInsertQuery insertLabelQuery = SqlInsertQuery.builder(mapper)
                        .schema(company)
                        .table(LABELS_TABLE)
                        .castField("result_id", resultId, "uuid")
                        .field("key", label.getKey())
                        .field("value", label.getValue())
                        .build();
                PreparedStatement insertLabelStmt = insertLabelQuery.prepareStatement(conn);
                int affectedLabelRows = insertLabelStmt.executeUpdate();
                if (affectedLabelRows <= 0) {
                    throw new SQLException("Failed to insert label=" + label);
                }
            }
            return resultId;
        }));
        try{
            if(CollectionUtils.isNotEmpty(pluginResult.getProductIds())) {
                mappingService.batchInsert(company, ComponentProductMapping.builder()
                        .componentId(UUID.fromString(resultId))
                        .componentType("plugin_result")
                        .productIds(pluginResult.getProductIds())
                        .build());
            }
        }
        catch(SQLException e){
            log.warn("Failed to insert the plugin_result - products <-> relation for the plugin result '{}' and the product ids '{}''", resultId, pluginResult.getProductIds(), e);
        }
        return finalId;
    }

    @Override
    public Boolean update(String company, DbPluginResult pluginResult) throws SQLException {
        throw new UnsupportedOperationException();
    }

    @Override
    public Optional<DbPluginResult> get(String company, String resultId) throws SQLException {
        String sql = "" +
                "SELECT r.*, p.name, p.tool, p.class, array_remove(array_agg(m.product_id), NULL)::int[] as product_ids " +
                "FROM " 
                    + company + "." + RESULTS_TABLE + " as r " 
                    + "LEFT JOIN " + company + "." + MAPPINGS_TABLE + " AS m " 
                        + "ON " 
                            + "m.component_id = r.id " 
                            + "AND m.component_type = 'plugin_result', "
                + company + ".plugins as p "
                + "WHERE " 
                    + "r.id = :id::uuid "
                    + "AND p.id = r.plugin_id "
                + "GROUP BY r.id, p.name, p.tool, p.class "
                + "LIMIT 1 ";

        Map<String, String> params = Map.of(
                "id", resultId
        );

        DbPluginResult result;
        try {
            result = template.queryForObject(sql, params, DbPluginResultConverters.rowMapperForOne(mapper));
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
        if (result == null) {
            return Optional.empty();
        }

        String labelsSql = "" +
                " SELECT key, value " +
                " FROM " + company + "." + LABELS_TABLE +
                " WHERE result_id = :id::uuid ";

        List<DbPluginResultLabel> labels = template.query(labelsSql, params, DbPluginResultConverters.labelRowMapper());
        return Optional.of(result.toBuilder()
                .labels(labels)
                .build());
    }

    private static String buildBasePluginListQuery(String company) {
        return "" +
                " SELECT " +
                "  r.*, " +
                "  p.name, " +
                "  p.tool, " +
                "  p.class, " +
                "  array_remove(array_agg(m.product_id), NULL)::int[] as product_ids, " +
                "    (" +
                "        SELECT " +
                "            json_agg(l) AS labels_agg" +
                "        FROM " +
                "        (" +
                "            SELECT" +
                "                labels_table.result_id," +
                "                labels_table.key," +
                "                array_remove(array_agg(labels_table.value), NULL) AS values" +
                "            FROM " + company + "." + LABELS_TABLE +
                "                AS labels_table" +
                "            WHERE " +
                "                labels_table.result_id = r.id" +
                "            GROUP BY " +
                "                labels_table.result_id," +
                "                labels_table.key" +
                "        ) AS l" +
                "    ) " +
                " FROM " 
                    + company + "." + RESULTS_TABLE + " AS r " 
                    + "LEFT JOIN " + company + "." + MAPPINGS_TABLE + " AS m " 
                        + "ON " 
                            + "m.component_id = r.id " 
                            + "AND m.component_type = 'plugin_result', "
                    + company + ".plugins AS p ";
    }

    @Override
    public DbListResponse<DbPluginResult> list(String company,
                                               Integer pageNumber,
                                               Integer pageSize) throws SQLException {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        String sql = buildBasePluginListQuery(company)
                + "WHERE " 
                    + "p.id = r.plugin_id "
                + "GROUP BY " 
                    + "r.id, "
                    + "p.name, " 
                    + "p.tool, " 
                    + "p.class "
                + "ORDER BY r.created_at DESC "
                + "OFFSET :skip "
                + "LIMIT :limit ";
        Map<String, ?> params = Map.of(
                "skip", skip,
                "limit", limit
        );

        List<DbPluginResult> pluginResults = template.query(sql, params, DbPluginResultConverters.rowMapperForList(mapper));

        return DbListResponse.of(pluginResults, null);
    }

    private List<String> buildFilterConditions(Map<String, Object> params,
                                        Set<UUID> resultIds,
                                        Set<UUID> pluginIds,
                                        Set<String> versions,
                                        Set<String> productIds,
                                        Boolean successful,
                                        Date from,
                                        Date to) { 
        List<String> conditions = new ArrayList<>();
        conditions.add("p.id = r.plugin_id");
        if (CollectionUtils.isNotEmpty(resultIds)) {
            conditions.add("r.id IN (" + resultIds.stream().map(id -> "'" + id.toString() + "'::uuid").collect(Collectors.joining(",")) + ")");
        }
        if (CollectionUtils.isNotEmpty(pluginIds)) {
            conditions.add("r.plugin_id IN (" + pluginIds.stream().map(p -> "'" + p.toString() + "'::uuid").collect(Collectors.joining(",")) + ")");
        }
        if (CollectionUtils.isNotEmpty(productIds)) {
            conditions.add("m.product_id IN (:product_ids)");
            params.put("product_ids", productIds.stream().map(Integer::valueOf).collect(Collectors.toList()));
        }
        if (CollectionUtils.isNotEmpty(versions)) {
            conditions.add("r.version IN (:versions)");
            params.put("versions", versions);
        }
        if (successful != null) {
            conditions.add("r.successful = :successful");
            params.put("successful", successful);
        }
        if (from != null) {
            conditions.add("r.created_at >= :from");
            params.put("from", DateUtils.toEpochSecond(from));
        }
        if (to != null) {
            conditions.add("r.created_at <= :to");
            params.put("to", DateUtils.toEpochSecond(to));
        }
        return conditions;
    }

    public DbListResponse<DbPluginResult> filter(String company,
                                                 Set<UUID> resultIds,
                                                 Set<UUID> pluginIds,
                                                 Set<String> versions,
                                                 Set<String> productIds,
                                                 Boolean successful,
                                                 Date from,
                                                 Date to,
                                                 Integer pageNumber,
                                                 Integer pageSize,
                                                 Map<String, SortingOrder> sorting) {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        Map<String, Object> params = new HashMap<>();
        params.put("skip", skip);
        params.put("limit", limit);

        List<String> filterConditions = buildFilterConditions(params, resultIds, pluginIds, versions, productIds, successful, from, to);

        String where = filterConditions.size() == 0 ? "" :
                " WHERE " + String.join(" AND ", filterConditions) + " ";
        String groupBy = "GROUP BY "
                            + "r.id, "
                            + "p.name, " 
                            + "p.tool, "
                            + "p.class ";

        String baseQuery = buildBasePluginListQuery(company);
        String countSql = "SELECT count(*) FROM (" + baseQuery + where + groupBy + " ) AS subquery";
        Integer count = template.queryForObject(countSql, params, Integer.class);

        String sortBy = getSortBy(sorting);

        String sql = baseQuery +
                where +
                groupBy +
                sortBy +
                " OFFSET :skip " +
                " LIMIT :limit ";
        List<DbPluginResult> pluginResults = template.query(sql, params, DbPluginResultConverters.rowMapperForList(mapper));

        return DbListResponse.of(pluginResults, count);
    }

    public DbListResponse<DbPluginResult> filterByLabels(
            String company,
                                                         Set<UUID> resultIds,
                                                         Set<UUID> pluginIds,
                                                         Set<String> versions,
                                                         Set<String> productIds,
                                                         Boolean successful,
                                                         List<DbPluginResultLabel> labels,
                                                         Date from,
                                                         Date to,
                                                         Integer pageNumber,
                                                         Integer pageSize,
                                                         Map<String, SortingOrder> sorting) {

        if (CollectionUtils.isEmpty(labels)) {
            return filter(company, resultIds, pluginIds, versions, productIds, successful, from, to, pageNumber, pageSize, sorting);
        }

        DbListResponse<String> labelsResultIds = filterResultIdsByLabels(company, resultIds, pluginIds, versions, productIds, successful, labels, from, to, pageNumber, pageSize, sorting);
        if (CollectionUtils.isEmpty(labelsResultIds.getRecords())) {
            return DbListResponse.of(List.of(), labelsResultIds.getTotalCount());
        }
        Map<String, Object> params = Map.of("result_ids", labelsResultIds.getRecords());
 
        String groupBy = "GROUP BY "
                            + "r.id, "
                            + "p.name, " 
                            + "p.tool, "
                            + "p.class ";
        String sortBy = getSortBy(sorting);
        String sql = buildBasePluginListQuery(company)
                + " WHERE " 
                    + "r.id::text IN (:result_ids) "
                    + "AND r.plugin_id = p.id "
                + groupBy
                + sortBy;
        List<DbPluginResult> pluginResults = template.query(sql, params, DbPluginResultConverters.rowMapperForList(mapper));
        return DbListResponse.of(pluginResults, labelsResultIds.getTotalCount());
    }

    // region label queries

    public DbListResponse<String> filterResultIdsByLabels(String company,
                                                Set<UUID> resultIds,
                                                Set<UUID> pluginIds,
                                                Set<String> versions,
                                                Set<String> productIds,
                                                Boolean successful,
                                                List<DbPluginResultLabel> labels,
                                                Date from,
                                                Date to,
                                                Integer pageNumber,
                                                Integer pageSize,
                                                Map<String, SortingOrder> sorting) {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        Map<String, Object> params = new HashMap<>();
        params.put("skip", skip);
        params.put("limit", limit);

        List<String> conditions = buildFilterConditions(params, resultIds, pluginIds, versions, productIds, successful, from, to);

        String labelsFilter = (labels == null) ? "" : labels.stream()
                .map(label -> label.getKey() + LABEL_KEY_VALUE_SEPATATOR + label.getValue())
                .collect(Collectors.joining(LABEL_ITEM_SEPATATOR));
        List<String> fromClause = new ArrayList<>();
        List<String> fieldSelection = new ArrayList<>();
        if (Strings.isNotBlank(labelsFilter)){
            fromClause.add("(SELECT result_id, array_agg(key||'" + LABEL_KEY_VALUE_SEPATATOR + "'||value) as labels " 
                            + "FROM " + company + "." + LABELS_TABLE
                            + " GROUP BY result_id) AS l");
            // fromClause.add(company + "." + LABELS_TABLE + " AS l");
            conditions.add("l.result_id = r.id");
            conditions.add("l.labels @> string_to_array(:labels_filter, '" + LABEL_ITEM_SEPATATOR + "')");
            params.put("labels_filter", labelsFilter);
            fieldSelection.add("l.labels");
        }
        if (CollectionUtils.isNotEmpty(productIds)){
            fromClause.add(
                company + "." + RESULTS_TABLE + " AS r " 
                + "LEFT JOIN " + company + "." + MAPPINGS_TABLE + " AS m " 
                    + "ON m.component_type = 'plugin_result' AND m.component_id = r.id");
        }
        else{
            fromClause.add(company + "." + RESULTS_TABLE + " AS r");
        }
        fromClause.add(company + "." + PLUGINS_TABLE + " AS p ");
        String baseQuery = " FROM " 
                            + String.join(" , ", fromClause)
                        + (conditions.size() > 0 ? "WHERE " + String.join(" AND ", conditions) : "") + " ";

        String countSql = "SELECT count(*) " + baseQuery;
        log.debug("Count query: {}",countSql);
        Integer count = template.queryForObject(countSql, params, Integer.class);

        fieldSelection.add("r.id");
        String sortBy = getSortBy(sorting);
        String sql = "SELECT " + String.join(",",fieldSelection) + baseQuery
                + sortBy
                + "OFFSET :skip "
                + "LIMIT :limit ";

        log.debug("Items query: {}", sql);
        List<String> filteredResultIds = template.query(sql, params, (rs, row) -> rs.getString("id"));

        return DbListResponse.of(filteredResultIds, count);
    }

    private String getSortBy(Map<String, SortingOrder> sorting) {
        return String.format(" ORDER BY %s ", ( sorting == null || sorting.size() < 1
                        ? "r.created_at DESC"
                        : String.join(", ", sorting.keySet().stream().map(key -> String.format("r.%s %s", key, sorting.get(key))).collect(Collectors.toList()))));
    }

    public List<String> searchLabelKeys(String company, String searchValue, Integer pageNumber, Integer pageSize) {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        Map<String, ?> params = Map.of(
                "skip", skip,
                "limit", limit,
                "search", searchValue + "%"
        );

        String where = Strings.isBlank(searchValue) ? " " : " WHERE key ILIKE :search ";

        String sql = "" +
                " SELECT DISTINCT(key) AS distinct_key " +
                " FROM " + company + "." + LABELS_TABLE +
                where +
                " ORDER BY distinct_key ASC " +
                " OFFSET :skip " +
                " LIMIT :limit ";

        return template.query(sql, params, (rs, row) -> rs.getString("distinct_key"));
    }

    public List<String> searchLabelValues(String company, String key, String searchValue, Integer pageNumber, Integer pageSize) {
        if (Strings.isEmpty(key)) {
            return List.of();
        }
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        Map<String, ?> params = Map.of(
                "skip", skip,
                "limit", limit,
                "key", key,
                "search", searchValue + "%"
        );

        String searchCondition = Strings.isBlank(searchValue) ? " " : " AND value ILIKE :search ";

        String sql = "" +
                " SELECT DISTINCT(value) AS distinct_value " +
                " FROM " + company + "." + LABELS_TABLE +
                " WHERE key = :key " + searchCondition +
                " ORDER BY distinct_value ASC " +
                " OFFSET :skip " +
                " LIMIT :limit ";
        return template.query(sql, params, (rs, row) -> rs.getString("distinct_value"));
    }

    public List<String> distinctLabelKeys(String company,
                                          Integer pageNumber,
                                          Integer pageSize) {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        Map<String, ?> params = Map.of(
                "skip", skip,
                "limit", limit
        );

        String sql = "" +
                " SELECT DISTINCT(key) AS distinct_key " +
                " FROM " + company + "." + LABELS_TABLE +
                " ORDER BY distinct_key ASC " +
                " OFFSET :skip " +
                " LIMIT :limit ";

        return template.query(sql, params, (rs, row) -> rs.getString("distinct_key"));
    }

    public List<String> distinctLabelValues(String company,
                                            String key,
                                            Integer pageNumber,
                                            Integer pageSize) {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
        Map<String, ?> params = Map.of(
                "key", key,
                "skip", skip,
                "limit", limit
        );


        String sql = "" +
                " SELECT " +
                "      value," +
                "      MAX(created_at) AS max_created_at " +
                " FROM " + company + "." + LABELS_TABLE +
                " WHERE key = :key " +
                " GROUP BY value " +
                " ORDER BY max_created_at DESC " +
                " OFFSET :skip " +
                " LIMIT :limit ";

        return template.query(sql, params, (rs, row) -> rs.getString("value"));
    }


//    /**
//     * Return label values grouped by keys.
//     * For scaling purposes, this is limit to the first 100 labels per key.
//     * To retrieve all values, use {@link PluginResultsDatabaseService#distinctLabelValues(java.lang.String, java.lang.String, java.lang.Integer, java.lang.Integer)}
//     */
//    public Map<String, List<String>> groupLabelsByKey(String company,
//                                                      Integer pageNumber,
//                                                      Integer pageSize) {
//        int limit = MoreObjects.firstNonNull(pageSize, 50);
//        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;
//        Map<String, ?> params = Map.of(
//                "skip", skip,
//                "limit", limit
//        );
//
//        String sql = "" +
//                " SELECT " +
//                "     key, " +
//                "     ARRAY_REMOVE( ARRAY (" +
//                "          SELECT value " +
//                "          FROM " + company + "." + LABELS_TABLE + " AS t2 " +
//                "          WHERE t1.key = t2.key " +
//                "          GROUP BY value " +
//                "          ORDER BY value ASC " +
//                "          LIMIT 100 " +
//                "     ), NULL) AS values " +
//                " FROM " + company + "." + LABELS_TABLE + " AS t1 " +
//                " GROUP BY key " +
//                " ORDER BY key ASC " +
//                " OFFSET :skip " +
//                " LIMIT :limit ";
//
//        Map<String, List<String>> results = new LinkedHashMap<>();
//        template.query(sql, params, (rs, row) -> {
//            String key = rs.getString("key");
//            String[] values = (String[]) rs.getArray("values").getArray();
//            results.put(key, Arrays.asList(values));
//            return null;
//        });
//        return results;
//    }

    //endregion


    @Override
    public Boolean delete(String company, String id) throws SQLException {
        String sql = "DELETE " +
                " FROM " + company + "." + RESULTS_TABLE +
                " WHERE id = :id::uuid";

        return template.update(sql, Map.of(
                "id", id
        )) > 0;
    }

    public int deleteBulkPluginResult(String company, List<String> ids) throws SQLException {
        int affectedRows = 0;
        //todo : remove caps
        if (CollectionUtils.isNotEmpty(ids)) {
            Map<String, Object> params = Map.of("ids", ids.stream().map(UUID::fromString)
                    .collect(Collectors.toList()));
            String sql = "DELETE FROM " + company + "." + RESULTS_TABLE + " WHERE id IN (:ids)";
            affectedRows = template.update(sql, params);
        }
        return affectedRows;
    }

    @Override
    public Boolean ensureTableExistence(String company) throws SQLException {
        List<String> sqlList = List.of(
                "CREATE TABLE IF NOT EXISTS " + company + "." + RESULTS_TABLE +
                        "(" +
                        "        id                UUID PRIMARY KEY DEFAULT uuid_generate_v4()," +
                        "        plugin_id         UUID NOT NULL," +
                        "        version           VARCHAR(40) NOT NULL," +
                        "        successful        BOOLEAN NOT NULL," +
                        "        metadata          JSONB," +
                        "        gcs_path          TEXT NOT NULL," +
                        "        created_at        BIGINT NOT NULL DEFAULT extract(epoch from now())" +
                        ")",

                "CREATE INDEX IF NOT EXISTS " + RESULTS_TABLE + "_plugin_id_idx  on " + company + "." + RESULTS_TABLE + " (plugin_id)",
                "CREATE INDEX IF NOT EXISTS version_idx    on " + company + "." + RESULTS_TABLE + " (version)",
                "CREATE INDEX IF NOT EXISTS successful_idx on " + company + "." + RESULTS_TABLE + " (successful)",
                "CREATE INDEX IF NOT EXISTS created_at_idx on " + company + "." + RESULTS_TABLE + " (created_at)",

                "CREATE TABLE IF NOT EXISTS " + company + "." + LABELS_TABLE +
                        "(" +
                        "        id               INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                        "        result_id        UUID NOT NULL" +
                        "                             REFERENCES " + company + "." + RESULTS_TABLE + "(id)" +
                        "                             ON DELETE CASCADE," +
                        "        key              TEXT," +
                        "        value            TEXT," +
                        "        created_at       BIGINT NOT NULL DEFAULT extract(epoch from now())" +
                        ")",
                "CREATE INDEX IF NOT EXISTS key_idx        on " + company + "." + LABELS_TABLE + " (key)",
                "CREATE INDEX IF NOT EXISTS value_idx      on " + company + "." + LABELS_TABLE + " (value)"
        );

        sqlList.forEach(template.getJdbcTemplate()::execute);
        return true;
    }

}
