package io.levelops.commons.databases.services;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.MoreObjects;
import io.levelops.commons.databases.converters.PluginConverters;
import io.levelops.commons.databases.models.database.Plugin;
import io.levelops.commons.models.DbListResponse;
import io.levelops.commons.databases.utils.DatabaseUtils;
import io.levelops.commons.databases.utils.SqlInsertQuery;
import io.levelops.commons.databases.utils.TransactionCallback;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

@Log4j2
@Service
public class PluginDatabaseService extends DatabaseService<Plugin> {

    private static final String PLUGIN_TABLE = "plugins";
    protected final NamedParameterJdbcTemplate template;
    private final ObjectMapper objectMapper;

    @Autowired
    public PluginDatabaseService(DataSource dataSource, ObjectMapper objectMapper) {
        super(dataSource);
        template = new NamedParameterJdbcTemplate(dataSource);
        this.objectMapper = objectMapper;
    }

    /**
     * NOTE: this does not return id unless insert was successful.
     */
    @Override
    public String insert(String company, Plugin plugin) throws SQLException {
        SqlInsertQuery insertQuery = SqlInsertQuery.builder(objectMapper)
                .schema(company)
                .table(PLUGIN_TABLE)
                .castField("id", plugin.getId() != null ? plugin.getId(): UUID.randomUUID(), "uuid")
                .field("custom", plugin.getCustom())
                .field("class", plugin.getPluginClass().toString())
                .field("tool", plugin.getTool())
                .field("version", plugin.getVersion())
                .field("name", plugin.getName())
                .field("description", plugin.getDescription())
                .jsonField("readme", plugin.getReadme())
                .field("gcs_path", plugin.getGcsPath())
                .returnAutoGeneratedKeys(true)
                .build();

        return template.getJdbcTemplate().execute(TransactionCallback.of(conn -> {
            PreparedStatement insertResultStmt = insertQuery.prepareStatement(conn);
            return DatabaseUtils.executeUpdateAndExtractGeneratedField(insertResultStmt,
                    rs -> rs.getObject("id"))
                    .map(String::valueOf)
                    .orElse(null);
        }));
    }


    @Override
    public Boolean update(String company, Plugin plugin) throws SQLException {
        throw new UnsupportedOperationException();
    }

    @Override
    public Optional<Plugin> get(String company, String pluginId) {
        String sql = "SELECT * " +
                " FROM " + company + "." + PLUGIN_TABLE + " " +
                " WHERE id = :id::uuid " +
                " LIMIT 1";

        try {
            return Optional.ofNullable(template.queryForObject(sql, Map.of("id", pluginId),
                    PluginConverters.pluginRowMapper(objectMapper)));
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        } catch (DataAccessException ex) {
            log.error(ex);
        }
        return Optional.empty();
    }

    public Optional<Plugin> getByTool(String company, String tool) {
        String sql = "SELECT * " +
                " FROM " + company + "." + PLUGIN_TABLE + " " +
                " WHERE tool = :tool " +
                " LIMIT 1";

        try {
            return Optional.ofNullable(template.queryForObject(sql, Map.of("tool", tool),
                    PluginConverters.pluginRowMapper(objectMapper)));
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        } catch (DataAccessException ex) {
            log.error(ex);
        }
        return Optional.empty();
    }

    @Override
    public DbListResponse<Plugin> list(String company, Integer pageNumber, Integer pageSize) throws SQLException {
        return listByFilter(company, null, null, pageNumber, pageSize);
    }

    public DbListResponse<Plugin> listByFilter(String company,
                                               String name,
                                               Boolean custom,
                                               Integer pageNumber,
                                               Integer pageSize) {
        int limit = MoreObjects.firstNonNull(pageSize, 50);
        int skip = MoreObjects.firstNonNull(pageNumber, 0) * limit;

        String criteria = " ";
        if (StringUtils.isNotEmpty(name)) {
            criteria = " WHERE name ILIKE :name ";
        }
        if (custom != null) {
            criteria += " AND custom = :custom::boolean ";
        }

        String sql = "SELECT * " +
                " FROM " + company + "." + PLUGIN_TABLE + " " +
                criteria +
                " OFFSET :skip " +
                " LIMIT :limit ";

        Map<String, ?> params = Map.of(
                "skip", skip,
                "limit", limit,
                "name", StringUtils.defaultString(
                        StringUtils.wrap(name, "%")),
                "custom", Boolean.TRUE.equals(custom));
        List<Plugin> results = template.query(sql, params, PluginConverters.pluginRowMapper(objectMapper));

        String countSql = "SELECT COUNT(id) FROM " + company + "." + PLUGIN_TABLE;
        Integer totalCount = template.queryForObject(countSql, params,
                (rs, row) -> rs.getInt("count"));

        return DbListResponse.of(results, totalCount);
    }

    @Override
    public Boolean delete(String company, String id) throws SQLException {
        String sql = "DELETE FROM " + company + "." + PLUGIN_TABLE +
                " WHERE id = :id";
        template.update(sql, Map.of("id", id));
        return true;
    }

    @Override
    public Boolean ensureTableExistence(String company) throws SQLException {
        List<String> sqlList = List.of("CREATE TABLE IF NOT EXISTS " + company + "." + PLUGIN_TABLE + " (" +
                        "        id          UUID PRIMARY KEY DEFAULT uuid_generate_v4()," +
                        "        custom      BOOLEAN NOT NULL," +
                        "        tool        VARCHAR(50) NOT NULL UNIQUE," +
                        "        version     VARCHAR(20) NOT NULL," +
                        "        name        VARCHAR NOT NULL," +
                        "        class       VARCHAR NOT NULL," +
                        "        description VARCHAR NOT NULL," +
                        "        readme      JSONB NOT NULL," +
                        "        gcs_path    VARCHAR NOT NULL," +
                        "        created_at  BIGINT DEFAULT extract(epoch from now())" +
                        ")",
                "CREATE INDEX IF NOT EXISTS " + PLUGIN_TABLE + "_tool_idx on " + company + "." + PLUGIN_TABLE + " (tool)",
                "CREATE INDEX IF NOT EXISTS " + PLUGIN_TABLE + "_name_idx on " + company + "." + PLUGIN_TABLE + " (name)",
                "CREATE INDEX IF NOT EXISTS " + PLUGIN_TABLE + "_class_idx on " + company + "." + PLUGIN_TABLE + " (class)",
                "CREATE INDEX IF NOT EXISTS " + PLUGIN_TABLE + "_custom_idx on " + company + "." + PLUGIN_TABLE + " (custom)",
                "INSERT INTO  " + company + ".plugins " +
                    "(custom, tool, version, name, description, created_at, readme, gcs_path, class)" +
                "VALUES" +
                    "(false, 'sast_brakeman', '1.0', 'Brakeman', 'Levelops Plugin for brakeman', extract(epoch from now()), '{}'::jsonb, '', 'sources_scan')," +
                    "(false, 'report_ms_tmt', '1.0', 'Microsoft Threat Modeling Tool', 'Ingests a Microsoft Threat Modeling Tool Report', extract(epoch from now()), '{}'::jsonb, '', 'report_file')," +
                    "(false, 'report_praetorian', '1.0', 'Praetorian Report', 'Ingests a Praetorian Report', extract(epoch from now()), '{}'::jsonb, '', 'report_file')," +
                    "(false, 'report_nccgroup', '1.0', 'NCC Group Report', 'Ingests a NCC Group Report', extract(epoch from now()), '{}'::jsonb, '', 'report_file')," +
                    "(false, 'csv', '1.0', 'CSV', 'Generic spreadsheet data formatted using Comma-Separated Values (CSV)', extract(epoch from now()), '{}'::jsonb, '', 'report_file')" +
                "ON CONFLICT(tool) DO UPDATE SET name = EXCLUDED.name, description = EXCLUDED.description, version = EXCLUDED.version;"
        );

        sqlList.forEach(template.getJdbcTemplate()::execute);
        return true;
    }

}