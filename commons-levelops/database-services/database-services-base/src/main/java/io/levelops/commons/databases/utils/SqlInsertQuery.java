package io.levelops.commons.databases.utils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Builder;
import lombok.Value;
import org.apache.logging.log4j.util.Strings;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Value
public class SqlInsertQuery implements SqlQuery {

    @Value
    @Builder(toBuilder = true)
    private static class Field {
        String name;
        Object value;
        String valueSql;
    }

    private final String schema;
    private final String table;
    private final List<Field> fields;
    private final boolean returnAutoGeneratedKeys;
    private final String onConflictTarget;
    private final String onConflictAction;

    private SqlInsertQuery(String schema, String table, List<Field> fields, boolean returnAutoGeneratedKeys, String onConflictTarget, String onConflictAction) {
        this.schema = schema;
        this.table = table;
        this.fields = fields;
        this.returnAutoGeneratedKeys = returnAutoGeneratedKeys;
        this.onConflictTarget = onConflictTarget;
        this.onConflictAction = onConflictAction;
    }

    private SqlInsertQuery(SqlInsertQueryBuilder builder) {
        this(builder.schema, builder.table, builder.fields, builder.returnAutoGeneratedKeys, builder.onConflictTarget, builder.onConflictAction);
    }

    @Override
    public String getSql() {
        return "INSERT INTO "
                + getTableSql()
                + "("
                + getFieldsSql()
                + ") VALUES ("
                + getValuesSql()
                + ")"
                + getOnConflict();
    }

    public String getOnConflict(){
        if (Strings.isNotBlank(onConflictAction) && Strings.isNotBlank(onConflictTarget)){
            return " ON CONFLICT (" + onConflictTarget + ") " + onConflictAction;
        }
        return "";
    }

    @Override
    public PreparedStatement setValues(PreparedStatement statement) throws SQLException {
        for (int i = 0; i < fields.size(); i++) {
            int columnIndex = i + 1;
            Field field = fields.get(i);
            statement.setObject(columnIndex, field.getValue());
        }
        return statement;
    }

    @Override
    public boolean getReturnAutoGeneratedKeys() {
        return returnAutoGeneratedKeys;
    }

    public String getFieldsSql() {
        return fields.stream()
                .map(Field::getName)
                .collect(Collectors.joining(","));
    }

    public String getValuesSql() {
        return fields.stream()
                .map(Field::getValueSql)
                .collect(Collectors.joining(","));
    }

    public String getTableSql() {
        if (schema == null) {
            return table;
        }
        return schema + "." + table;
    }

    public static SqlInsertQueryBuilder builder(ObjectMapper mapper) {
        return new SqlInsertQueryBuilder(mapper);
    }

    public static class SqlInsertQueryBuilder {

        private final ObjectMapper mapper;
        private String schema;
        private String table;
        private boolean returnAutoGeneratedKeys = false;
        private String onConflictTarget;
        private String onConflictAction;
        private List<Field> fields = new ArrayList<>();

        private SqlInsertQueryBuilder(ObjectMapper mapper) {
            this.mapper = mapper;
        }

        public SqlInsertQueryBuilder schema(String schema) {
            this.schema = schema;
            return this;
        }

        public SqlInsertQueryBuilder table(String table) {
            this.table = table;
            return this;
        }

        public SqlInsertQueryBuilder returnAutoGeneratedKeys(boolean returnAutoGeneratedKeys) {
            this.returnAutoGeneratedKeys = returnAutoGeneratedKeys;
            return this;
        }

        public SqlInsertQueryBuilder field(String name, String valueSql, Object value) {
            fields.add(Field.builder()
                    .name(name)
                    .valueSql(valueSql)
                    .value(value)
                    .build());
            return this;
        }

        public SqlInsertQueryBuilder sqlField(String name, String valueSql) {
            fields.add(Field.builder()
                    .name(name)
                    .valueSql(valueSql)
                    .build());
            return this;
        }

        public SqlInsertQueryBuilder field(String name, Object value) {
            fields.add(Field.builder()
                    .name(name)
                    .valueSql("?")
                    .value(value)
                    .build());
            return this;
        }

        public SqlInsertQueryBuilder castField(String name, Object value, String castAs) {
            fields.add(Field.builder()
                    .name(name)
                    .valueSql("?::" + castAs)
                    .value(value)
                    .build());
            return this;
        }

        public SqlInsertQueryBuilder jsonField(String name, Object value) throws SQLException {
            try {
                String json = mapper.writeValueAsString(value);
                fields.add(Field.builder()
                        .name(name)
                        .valueSql("to_json(?::json)")
                        .value(json)
                        .build());
                return this;
            } catch (JsonProcessingException e) {
                throw new SQLException("Failed to serialize field '" + name + "'", e);
            }
        }

        public SqlInsertQueryBuilder onConflict(final String target, final String action){
            this.onConflictTarget = target;
            this.onConflictAction = action;
            return this;
        }

        public SqlInsertQuery build() {
            return new SqlInsertQuery(this);
        }

    }

}
